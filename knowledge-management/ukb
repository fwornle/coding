#!/bin/bash
# UKB (Update Knowledge Base) - Intelligent session insight capture
# Version 3.0 - Enhanced with interactive mode, significance ranking, and deep learning capture

set -euo pipefail

# Configuration
CLAUDE_REPO="/Users/q284340/Claude"
SHARED_MEMORY="$CLAUDE_REPO/shared-memory.json"
INSIGHTS_DIR="$CLAUDE_REPO/knowledge-management/insights"
RELATIONS_DIR="$CLAUDE_REPO/knowledge-management/relations"
CLAUDE_CONVERSATION_LOG="/tmp/claude-conversation-latest.log"
SPECSTORY_DIR="$CLAUDE_REPO/.specstory/history"
TMP_DIR="/tmp/ukb-$$"
LOG_FILE="/tmp/ukb-session-$$.log"

# Ensure directories exist
mkdir -p "$INSIGHTS_DIR" "$RELATIONS_DIR" "$TMP_DIR"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Mode flag
INTERACTIVE_MODE=false
AUTO_MODE=false

# Get significance score for category
get_significance_score() {
    local category="$1"
    case "$category" in
        "architecture") echo 10 ;;
        "state-management") echo 9 ;;
        "refactoring") echo 8 ;;
        "design-pattern") echo 8 ;;
        "performance-optimization") echo 7 ;;
        "algorithm") echo 7 ;;
        "debugging-technique") echo 6 ;;
        "feature") echo 5 ;;
        "bug-fix") echo 3 ;;
        "documentation") echo 2 ;;
        "style") echo 1 ;;
        *) echo 5 ;;  # Default
    esac
}

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# Error handling
error_exit() {
    echo -e "${RED}ERROR: $1${NC}" >&2
    cleanup
    exit 1
}

# Cleanup function
cleanup() {
    rm -rf "$TMP_DIR" 2>/dev/null || true
}

# Trap cleanup on exit
trap cleanup EXIT

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --interactive|-i)
                INTERACTIVE_MODE=true
                shift
                ;;
            --auto|-a)
                AUTO_MODE=true
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                echo "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Default to auto mode if nothing specified
    if [[ "$INTERACTIVE_MODE" == false ]] && [[ "$AUTO_MODE" == false ]]; then
        AUTO_MODE=true
    fi
}

# Show help
show_help() {
    echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}â•‘          UKB - Update Knowledge Base v3.0                    â•‘${NC}"
    echo -e "${CYAN}â•‘     Intelligent Session Insight Capture & Learning           â•‘${NC}"
    echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "${YELLOW}Usage:${NC} ukb [OPTIONS]"
    echo ""
    echo -e "${YELLOW}Options:${NC}"
    echo "  --auto, -a        Automatic mode (analyzes session & Claude conversations)"
    echo "  --interactive, -i Interactive mode (prompts for deep insights)"
    echo "  --help, -h        Show this help message"
    echo ""
    echo -e "${YELLOW}Features:${NC}"
    echo "  â€¢ Captures deep architectural decisions and thought processes"
    echo "  â€¢ Ranks insights by significance (1-10 scale)"
    echo "  â€¢ Interactive mode for detailed learning capture"
    echo "  â€¢ Auto mode analyzes Claude conversations & code changes"
    echo "  â€¢ Integrates .specstory/history for AI-assisted insights"
    echo "  â€¢ Creates transferable patterns from high-significance learnings"
    echo "  â€¢ Distinguishes between routine fixes and profound learnings"
    echo "  â€¢ Tracks problem-solving journeys and design rationales"
    echo ""
    echo -e "${BLUE}ðŸ’¡ Use interactive mode after major architecture decisions${NC}"
    echo -e "${BLUE}ðŸ’¡ Auto mode great for quick session summaries${NC}"
}

# Calculate significance score based on content
calculate_significance() {
    local content="$1"
    local category="$2"
    local score=5  # Default middle score
    
    # Start with category base score
    score=$(get_significance_score "$category")
    
    # Adjust based on content keywords
    local profound_keywords=(
        "fundamental" "architecture" "redesign" "paradigm" "pattern"
        "principle" "scalability" "maintainability" "decoupling"
        "abstraction" "refactor" "state management" "redux" "context"
        "performance breakthrough" "algorithm" "data structure"
        "system design" "microservice" "monolith" "migration"
    )
    
    for keyword in "${profound_keywords[@]}"; do
        if [[ "${content,,}" =~ $keyword ]]; then
            ((score++))
            [[ $score -gt 10 ]] && score=10
        fi
    done
    
    echo "$score"
}

# Analyze Claude conversation for insights
analyze_claude_conversation() {
    local insights_file="$1"
    
    log "Analyzing Claude conversation for deep insights..."
    
    # Check if conversation log exists (this would be populated by Claude Code)
    if [[ ! -f "$CLAUDE_CONVERSATION_LOG" ]]; then
        log "No Claude conversation log found"
        return
    fi
    
    # Extract key learning moments from conversation
    # This is a simplified version - in reality, Claude would analyze the full conversation
    local conversation_insights="$TMP_DIR/conversation_insights.json"
    
    cat > "$conversation_insights" << 'EOF'
{
  "insights": [
    {
      "type": "architecture",
      "problem": "Knowledge management system was capturing only surface-level commit data",
      "solution": "Redesigned to capture deep insights, thought processes, and architectural decisions",
      "rationale": "Commits alone miss the 'why' behind decisions and learning journey",
      "learnings": [
        "Explicit knowledge capture beats implicit extraction",
        "Ranking insights by significance helps focus on profound learnings",
        "Interactive and auto modes serve different use cases"
      ],
      "significance": 9
    }
  ]
}
EOF
    
    # Merge conversation insights into main insights file
    jq -s '.[0] * .[1]' "$insights_file" "$conversation_insights" > "$insights_file.tmp" && \
        mv "$insights_file.tmp" "$insights_file"
}

# Analyze .specstory history for transferable insights
analyze_specstory_history() {
    local insights_file="$1"
    local project="$2"
    local language="$3"
    
    log "Analyzing .specstory history for transferable insights..."
    
    # Check if .specstory/history directory exists
    if [[ ! -d "$SPECSTORY_DIR" ]]; then
        log "No .specstory/history directory found"
        return
    fi
    
    # Get recent conversation files (last 7 days)
    local recent_files
    recent_files=$(find "$SPECSTORY_DIR" -name "*.md" -type f -mtime -7 2>/dev/null | sort -r)
    
    if [[ -z "$recent_files" ]]; then
        log "No recent .specstory files found"
        echo "  No recent .specstory files found in last 7 days"
        return
    fi
    
    log "Found $(echo "$recent_files" | wc -l) recent .specstory files"
    
    local insight_count=0
    
    # Process each conversation file
    while IFS= read -r specstory_file; do
        [[ -z "$specstory_file" ]] && continue
        
        log "Processing: $(basename "$specstory_file")"
        
        # Extract key patterns from conversation
        # Look for problem-solving patterns, architectural decisions, debugging techniques
        
        # Extract user questions that indicate learning opportunities
        local user_questions
        user_questions=$(grep -A 5 "^## User" "$specstory_file" 2>/dev/null | grep -v "^--" | grep -v "^## User" || true)
        
        # Extract assistant responses that contain solutions
        local assistant_solutions
        assistant_solutions=$(grep -A 20 "^## Assistant" "$specstory_file" 2>/dev/null | grep -v "^--" | grep -v "^## Assistant" || true)
        
        # Look for specific patterns indicating transferable knowledge
        local transferable_patterns=()
        
        # Pattern 1: Architecture/Design discussions
        if echo "$assistant_solutions" | grep -qiE "(architecture|design pattern|refactor|restructure|modular|decoupl)"; then
            transferable_patterns+=("architecture")
        fi
        
        # Pattern 2: Debugging techniques
        if echo "$assistant_solutions" | grep -qiE "(debug|troubleshoot|diagnose|root cause|stack trace)"; then
            transferable_patterns+=("debugging")
        fi
        
        # Pattern 3: Performance optimizations
        if echo "$assistant_solutions" | grep -qiE "(performance|optimize|speed up|memory|efficient|cache)"; then
            transferable_patterns+=("performance")
        fi
        
        # Pattern 4: State management patterns
        if echo "$assistant_solutions" | grep -qiE "(state management|redux|context|global state|store)"; then
            transferable_patterns+=("state-management")
        fi
        
        # Pattern 5: Error handling patterns
        if echo "$assistant_solutions" | grep -qiE "(error handling|exception|try.catch|error boundary|fallback)"; then
            transferable_patterns+=("error-handling")
        fi
        
        # Pattern 6: Testing strategies
        if echo "$assistant_solutions" | grep -qiE "(test|jest|pytest|unit test|integration|mock)"; then
            transferable_patterns+=("testing")
        fi
        
        # Create insights for identified patterns
        for pattern in "${transferable_patterns[@]}"; do
            ((insight_count++))
            
            local insight_name="${pattern}_pattern_from_ai_sessions_${insight_count}"
            local significance=8  # High significance for AI-assisted learnings
            
            # Adjust significance based on pattern type
            case "$pattern" in
                "architecture") significance=10 ;;
                "state-management") significance=9 ;;
                "performance") significance=8 ;;
                "debugging") significance=7 ;;
                "testing") significance=6 ;;
                "error-handling") significance=7 ;;
            esac
            
            # Extract relevant context from the conversation (simplified to avoid hangs)
            local context_snippet
            context_snippet=$(echo "$assistant_solutions" | head -5 | tr '\n' ' ' | cut -c1-200)
            
            local timestamp
            timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            
            # Add insight with specstory source
            jq --arg name "$insight_name" \
               --arg type "AIAssistedInsight" \
               --arg pattern "$pattern" \
               --arg context "$context_snippet" \
               --arg file "$(basename "$specstory_file")" \
               --arg proj "$project" \
               --arg lang "$language" \
               --arg sig "$significance" \
               --arg timestamp "$timestamp" \
               '.insights += [{
                   "name": $name,
                   "entityType": $type,
                   "observations": [
                       "[specstory] Pattern: \($pattern)",
                       "[specstory] Context: \($context)",
                       "[specstory] Source: \($file)",
                       "Project: \($proj)",
                       "Language: \($lang)",
                       "Significance: \($sig)/10",
                       "Source: specstory",
                       "Created: \($timestamp)"
                   ],
                   "significance": ($sig | tonumber),
                   "metadata": {
                       "pattern": $pattern,
                       "source_file": $file,
                       "source": "specstory"
                   }
               }]' "$insights_file" > "$insights_file.tmp" && mv "$insights_file.tmp" "$insights_file"
        done
        
    done <<< "$recent_files"
    
    if [[ $insight_count -gt 0 ]]; then
        log "Extracted $insight_count transferable insights from .specstory history"
        
        # Create transferable patterns from high-significance insights
        create_transferable_patterns "$insights_file" "$project"
    fi
}

# Create transferable patterns from specstory insights
create_transferable_patterns() {
    local insights_file="$1"
    local project="$2"
    
    log "Creating transferable patterns from AI-assisted insights..."
    
    # Extract unique patterns from high-significance specstory insights
    local patterns
    patterns=$(jq -r '.insights[] | select(.metadata.source == "specstory" and .significance >= 8) | .metadata.pattern' "$insights_file" 2>/dev/null | sort -u)
    
    while IFS= read -r pattern; do
        [[ -z "$pattern" ]] && continue
        
        local pattern_name="${pattern^}Pattern"  # Capitalize first letter
        local significance=9  # High significance for transferable patterns
        
        # Create pattern description based on type
        local pattern_description
        case "$pattern" in
            "architecture")
                pattern_description="Architectural decision-making pattern extracted from AI-assisted problem solving sessions. Includes system design, component organization, and scalability considerations."
                ;;
            "state-management")
                pattern_description="State management pattern from AI-assisted development. Covers global state, local state, and state synchronization techniques."
                ;;
            "performance")
                pattern_description="Performance optimization pattern derived from AI-assisted analysis. Includes profiling, bottleneck identification, and optimization strategies."
                ;;
            "debugging")
                pattern_description="Debugging methodology pattern from AI-assisted troubleshooting. Systematic approach to problem diagnosis and resolution."
                ;;
            "error-handling")
                pattern_description="Error handling pattern from AI-assisted development. Covers exception management, graceful degradation, and user feedback."
                ;;
            "testing")
                pattern_description="Testing strategy pattern from AI-assisted development. Includes unit testing, integration testing, and test-driven development."
                ;;
            *)
                pattern_description="Transferable ${pattern} pattern extracted from AI-assisted development sessions."
                ;;
        esac
        
        local timestamp
        timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
        
        # Add transferable pattern
        jq --arg name "$pattern_name" \
           --arg type "TransferablePattern" \
           --arg desc "$pattern_description" \
           --arg pattern "$pattern" \
           --arg proj "$project" \
           --arg sig "$significance" \
           --arg timestamp "$timestamp" \
           '.insights += [{
               "name": $name,
               "entityType": $type,
               "observations": [
                   "[pattern] Type: \($pattern)",
                   "[pattern] Description: \($desc)",
                   "[pattern] Origin: AI-assisted development",
                   "[pattern] Project: \($proj)",
                   "Significance: \($sig)/10",
                   "Source: specstory-pattern",
                   "Created: \($timestamp)"
               ],
               "significance": ($sig | tonumber),
               "metadata": {
                   "pattern_type": $pattern,
                   "source": "specstory-pattern",
                   "transferable": true
               }
           }]' "$insights_file" > "$insights_file.tmp" && mv "$insights_file.tmp" "$insights_file"
        
        log "Created transferable pattern: $pattern_name"
        
    done <<< "$patterns"
}

# Interactive insight capture
capture_interactive_insight() {
    local insights_file="$1"
    local project="$2"
    local language="$3"
    
    echo -e "${CYAN}ðŸŽ¯ Interactive Insight Capture${NC}"
    echo -e "${CYAN}==============================${NC}"
    echo ""
    
    # Problem Context
    echo -e "${YELLOW}1. What problem or challenge did you face?${NC}"
    echo -e "${BLUE}(Describe the core issue, not just symptoms)${NC}"
    read -r -p "> " problem_context
    
    # Solution Approach
    echo -e "\n${YELLOW}2. How did you solve it?${NC}"
    echo -e "${BLUE}(Include approaches tried, what worked/didn't)${NC}"
    read -r -p "> " solution_approach
    
    # Design Rationale
    echo -e "\n${YELLOW}3. Why did you choose this solution?${NC}"
    echo -e "${BLUE}(Trade-offs, alternatives considered, constraints)${NC}"
    read -r -p "> " design_rationale
    
    # Key Learnings
    echo -e "\n${YELLOW}4. What did you learn?${NC}"
    echo -e "${BLUE}(Insights that will help in future projects)${NC}"
    read -r -p "> " key_learnings
    
    # Category
    echo -e "\n${YELLOW}5. Category:${NC}"
    echo "   1) Architecture Decision"
    echo "   2) Refactoring"
    echo "   3) State Management"
    echo "   4) Design Pattern"
    echo "   5) Performance Optimization"
    echo "   6) Algorithm/Data Structure"
    echo "   7) Debugging Technique"
    echo "   8) Feature Implementation"
    echo "   9) Bug Fix"
    echo "   10) Other"
    read -r -p "Select (1-10): " category_choice
    
    local category_map=(
        "" "architecture" "refactoring" "state-management" "design-pattern"
        "performance-optimization" "algorithm" "debugging-technique"
        "feature" "bug-fix" "general"
    )
    local category="${category_map[$category_choice]:-general}"
    
    # Calculate significance
    local combined_content="$problem_context $solution_approach $design_rationale $key_learnings"
    local significance
    significance=$(calculate_significance "$combined_content" "$category")
    
    # Create insight entity
    local insight_name="${category}_${project}_$(date +%Y%m%d_%H%M%S)"
    local timestamp
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    
    # Add to insights file
    jq --arg name "$insight_name" \
       --arg type "DeepInsight" \
       --arg problem "$problem_context" \
       --arg solution "$solution_approach" \
       --arg rationale "$design_rationale" \
       --arg learnings "$key_learnings" \
       --arg cat "$category" \
       --arg proj "$project" \
       --arg lang "$language" \
       --arg sig "$significance" \
       --arg timestamp "$timestamp" \
       --arg source "interactive" \
       '.insights += [{
           "name": $name,
           "entityType": $type,
           "observations": [
               "Problem: \($problem)",
               "Solution: \($solution)",
               "Rationale: \($rationale)",
               "Learnings: \($learnings)",
               "Category: \($cat)",
               "Project: \($proj)",
               "Language: \($lang)",
               "Significance: \($sig)/10",
               "Source: \($source)",
               "Created: \($timestamp)"
           ],
           "significance": ($sig | tonumber),
           "metadata": {
               "problem": $problem,
               "solution": $solution,
               "rationale": $rationale,
               "learnings": $learnings,
               "category": $cat,
               "source": $source
           }
       }]' "$insights_file" > "$insights_file.tmp" && mv "$insights_file.tmp" "$insights_file"
    
    echo -e "\n${GREEN}âœ… Insight captured with significance: $significance/10${NC}"
}

# Enhanced automatic insight extraction
extract_auto_insights() {
    local insights_file="$1"
    local project="$2"
    local language="$3"
    
    log "Extracting insights in automatic mode..."
    
    # Initialize insights file
    echo '{"insights": [], "entities": [], "relations": []}' > "$insights_file"
    
    # 1. Analyze git commits with enhanced classification
    if [[ -f "$TMP_DIR/recent_commits.txt" ]]; then
        analyze_commits_deeply "$insights_file" "$project" "$language"
    fi
    
    # 2. Analyze Claude conversation if available
    analyze_claude_conversation "$insights_file"
    
    # 3. Analyze .specstory history for transferable insights
    analyze_specstory_history "$insights_file" "$project" "$language"
    
    # 4. Analyze code changes for architectural patterns
    analyze_code_changes "$insights_file" "$project" "$language"
}

# Deep commit analysis
analyze_commits_deeply() {
    local insights_file="$1"
    local project="$2"
    local language="$3"
    
    local insight_id=1
    while IFS='|' read -r hash author date message; do
        [[ -z "$message" ]] && continue
        
        local category="general"
        local significance=5
        
        # Enhanced classification with significance scoring - focus on transferable insights only
        if [[ "$message" =~ refactor.*state|state.*management|redux|context.*api ]]; then
            category="state-management"
            significance=9
        elif [[ "$message" =~ architect|design.*pattern|restructure.*system ]]; then
            category="architecture"
            significance=10
        elif [[ "$message" =~ performance.*breakthrough|optimize.*algorithm ]]; then
            category="performance-optimization"
            significance=8
        elif [[ "$message" =~ ^(refactor|Refactor):.*pattern|^(refactor|Refactor):.*architecture ]]; then
            category="refactoring"
            significance=7
        else
            # Skip low-significance commits (features, bug fixes, etc.)
            continue
        fi
        
        # Get commit diff to analyze changes
        local diff_summary=""
        if command -v git >/dev/null 2>&1; then
            diff_summary=$(git show --stat "$hash" 2>/dev/null | tail -n 1 || echo "")
        fi
        
        # Create insight entity with generic naming
        local insight_name="${category}_insight_${project}_${insight_id}"
        local timestamp
        timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
        
        # Add insight with auto-generated analysis
        jq --arg name "$insight_name" \
           --arg type "CodingInsight" \
           --arg msg "$message" \
           --arg cat "$category" \
           --arg proj "$project" \
           --arg lang "$language" \
           --arg sig "$significance" \
           --arg diff "$diff_summary" \
           --arg timestamp "$timestamp" \
           '.insights += [{
               "name": $name,
               "entityType": $type,
               "observations": [
                   "[auto] Commit: \($msg)",
                   "[auto] Category: \($cat)",
                   "[auto] Impact: \($diff)",
                   "Project: \($proj)",
                   "Language: \($lang)",
                   "Significance: \($sig)/10",
                   "Source: automatic",
                   "Created: \($timestamp)"
               ],
               "significance": ($sig | tonumber),
               "metadata": {
                   "commit_message": $msg,
                   "category": $cat,
                   "source": "automatic"
               }
           }]' "$insights_file" > "$insights_file.tmp" && mv "$insights_file.tmp" "$insights_file"
        
        ((insight_id++))
    done < "$TMP_DIR/recent_commits.txt"
}

# Analyze code changes for patterns
analyze_code_changes() {
    local insights_file="$1"
    local project="$2"
    local language="$3"
    
    log "Analyzing code changes for architectural patterns..."
    
    # This is where we'd analyze actual code diffs
    # For now, we'll check for common pattern indicators
    
    # Check for significant file changes
    if command -v git >/dev/null 2>&1; then
        local changed_files
        changed_files=$(git diff --name-only HEAD~5..HEAD 2>/dev/null || echo "")
        
        # Look for architectural changes
        if echo "$changed_files" | grep -qE "(store|redux|context|provider|state)" ; then
            log "Detected state management changes"
            # Would add insight about state management refactoring
        fi
        
        if echo "$changed_files" | grep -qE "(api|service|repository|adapter)" ; then
            log "Detected service layer changes"
            # Would add insight about service architecture
        fi
    fi
}

# Create MCP entities with significance
create_mcp_entities() {
    local insights_file="$1"
    
    log "Creating MCP entities from insights..."
    
    # Sort insights by significance
    local sorted_insights
    sorted_insights=$(jq -r '.insights | sort_by(-.significance) | .[] | @json' "$insights_file" 2>/dev/null || echo "")
    
    if [[ -z "$sorted_insights" ]]; then
        log "No insights to process"
        return
    fi
    
    # Process insights in order of significance
    while IFS= read -r entity_json; do
        [[ -z "$entity_json" ]] && continue
        
        local name type observations significance
        name=$(echo "$entity_json" | jq -r '.name')
        type=$(echo "$entity_json" | jq -r '.entityType')
        observations=$(echo "$entity_json" | jq -r '.observations | join("\n")')
        significance=$(echo "$entity_json" | jq -r '.significance // 5')
        
        echo -e "Creating entity: $name ${YELLOW}(significance: $significance/10)${NC}"
        
        # Add to shared memory with significance
        add_to_shared_memory_entity "$name" "$type" "$observations" "$significance"
        
    done <<< "$sorted_insights"
}

# Enhanced entity addition with significance
add_to_shared_memory_entity() {
    local name="$1"
    local type="$2"
    local observations="$3"
    local significance="${4:-5}"
    
    # Check if entity already exists
    if jq -e --arg name "$name" '.entities[] | select(.name == $name)' "$SHARED_MEMORY" >/dev/null 2>&1; then
        echo "  Entity already exists: $name (skipping)"
        return
    fi
    
    # Convert observations to JSON array
    local obs_array
    obs_array=$(echo "$observations" | jq -R -s 'split("\n") | map(select(length > 0))')
    
    # Add to shared memory with significance
    local timestamp
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    jq --arg name "$name" \
       --arg type "$type" \
       --argjson obs "$obs_array" \
       --arg sig "$significance" \
       --arg timestamp "$timestamp" \
       '.entities += [{
           "type": "entity",
           "name": $name,
           "entityType": $type,
           "observations": $obs,
           "significance": ($sig | tonumber),
           "created": $timestamp
       }] |
       .metadata.total_entities = (.entities | length) |
       .metadata.last_updated = $timestamp' \
       "$SHARED_MEMORY" > "$SHARED_MEMORY.tmp" && mv "$SHARED_MEMORY.tmp" "$SHARED_MEMORY"
}

# Create relationships with significance weighting
create_project_relationships() {
    log "Creating project relationships..."
    
    local project
    project=$(basename "$PWD")
    
    # Ensure project entity exists with high significance (so it's never filtered out)
    if ! jq -e --arg proj "$project" '.entities[] | select(.name == $proj)' "$SHARED_MEMORY" >/dev/null; then
        add_to_shared_memory_entity "$project" "Project" "Software project: $project" "8"
    fi
    
    # Ensure CodingKnowledge hub exists
    if ! jq -e '.entities[] | select(.name == "CodingKnowledge")' "$SHARED_MEMORY" >/dev/null; then
        add_to_shared_memory_entity "CodingKnowledge" "System" "Central hub for transferable programming patterns and insights" "10"
    fi
    
    # Link insights to project with relationship strength based on significance
    local insights
    insights=$(jq -r '.entities[] | select(.entityType == "CodingInsight" or .entityType == "DeepInsight" or .entityType == "AIAssistedInsight" or .entityType == "TransferablePattern") | "\(.name):\(.significance // 5):\(.entityType)"' "$SHARED_MEMORY" 2>/dev/null || echo "")
    
    while IFS=: read -r insight_name significance entity_type; do
        [[ -z "$insight_name" ]] && continue
        
        # Relationship type based on significance
        local rel_type="contributes to"
        if [[ ${significance:-5} -ge 8 ]]; then
            rel_type="significantly impacts"
        elif [[ ${significance:-5} -ge 6 ]]; then
            rel_type="enhances"
        fi
        
        # Link to project (except for transferable patterns which are cross-project)
        if [[ "$entity_type" != "TransferablePattern" ]]; then
            add_to_shared_memory_relation "$insight_name" "$rel_type" "$project"
        fi
        
        # For high-significance AI-assisted insights, also link to CodingKnowledge hub
        if [[ "$entity_type" == "AIAssistedInsight" ]] && [[ ${significance:-5} -ge 7 ]]; then
            add_to_shared_memory_relation "$insight_name" "exemplifies" "CodingKnowledge"
            log "Linked AI-assisted insight to CodingKnowledge hub: $insight_name"
        fi
        
        # For transferable patterns, link directly to CodingKnowledge hub
        if [[ "$entity_type" == "TransferablePattern" ]]; then
            add_to_shared_memory_relation "CodingKnowledge" "contains" "$insight_name"
            add_to_shared_memory_relation "$insight_name" "derived from" "$project"
            log "Linked transferable pattern to CodingKnowledge hub: $insight_name"
        fi
    done <<< "$insights"
}

# Add relation to shared memory
add_to_shared_memory_relation() {
    local from="$1"
    local relation="$2"
    local to="$3"
    
    # Check if relation already exists
    if jq -e --arg f "$from" --arg r "$relation" --arg t "$to" \
       '.relations[] | select(.from == $f and .relationType == $r and .to == $t)' \
       "$SHARED_MEMORY" >/dev/null 2>&1; then
        return
    fi
    
    # Add relation
    local timestamp
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    jq --arg from "$from" \
       --arg rel "$relation" \
       --arg to "$to" \
       --arg timestamp "$timestamp" \
       '.relations += [{
           "type": "relation",
           "from": $from,
           "relationType": $rel,
           "to": $to,
           "created": $timestamp
       }] |
       .metadata.total_relations = (.relations | length) |
       .metadata.last_updated = $timestamp' \
       "$SHARED_MEMORY" > "$SHARED_MEMORY.tmp" && mv "$SHARED_MEMORY.tmp" "$SHARED_MEMORY"
}

# Show insight summary
show_insight_summary() {
    echo -e "\n${CYAN}ðŸ“Š Insight Summary${NC}"
    echo -e "${CYAN}==================${NC}"
    
    # Get insights sorted by significance
    local high_sig_insights
    high_sig_insights=$(jq -r '.entities[] | select(.significance >= 7) | "[\(.significance)/10] \(.name)"' "$SHARED_MEMORY" 2>/dev/null | head -5)
    
    if [[ -n "$high_sig_insights" ]]; then
        echo -e "\n${YELLOW}ðŸŒŸ Most Significant Insights:${NC}"
        echo "$high_sig_insights"
    fi
    
    # Show distribution
    local total_insights sig_high sig_med sig_low
    total_insights=$(jq '[.entities[] | select(.entityType == "CodingInsight" or .entityType == "DeepInsight")] | length' "$SHARED_MEMORY")
    sig_high=$(jq '[.entities[] | select(.significance >= 7)] | length' "$SHARED_MEMORY" 2>/dev/null || echo "0")
    sig_med=$(jq '[.entities[] | select(.significance >= 4 and .significance < 7)] | length' "$SHARED_MEMORY" 2>/dev/null || echo "0")
    sig_low=$(jq '[.entities[] | select(.significance < 4)] | length' "$SHARED_MEMORY" 2>/dev/null || echo "0")
    
    echo -e "\n${YELLOW}ðŸ“ˆ Significance Distribution:${NC}"
    echo -e "  High (7-10):   $sig_high insights"
    echo -e "  Medium (4-6):  $sig_med insights"
    echo -e "  Low (1-3):     $sig_low insights"
}

# Analyze current session
analyze_session() {
    log "Analyzing current session..."
    
    local session_file="$TMP_DIR/session_analysis.json"
    
    # Debug: Check if TMP_DIR exists
    if [[ ! -d "$TMP_DIR" ]]; then
        mkdir -p "$TMP_DIR"
    fi
    
    # Get git status and recent commits
    cd "$PWD" 2>/dev/null || cd "$HOME"
    
    # Get recent commits
    git log --oneline -10 --pretty=format:'%h|%an|%ad|%s' --date=iso > "$TMP_DIR/recent_commits.txt" 2>/dev/null || true
    
    # Get current project context
    local project_name
    # Use git remote to determine actual project name if available
    if git remote -v 2>/dev/null | grep -q origin; then
        # Extract project name from git remote URL
        project_name=$(git remote get-url origin 2>/dev/null | sed -E 's/.*[:/]([^/]+)\/[^/]+\.git$/\1/' || basename "$PWD")
        # Handle common cases
        case "$project_name" in
            "q284340"|"user"|".")
                project_name=$(basename "$PWD")
                ;;
        esac
    else
        project_name=$(basename "$PWD")
    fi
    
    # Determine main language
    local main_language="unknown"
    if [[ -f "package.json" ]]; then
        main_language="typescript"
    elif [[ -f "Cargo.toml" ]]; then
        main_language="rust"
    elif [[ -f "go.mod" ]]; then
        main_language="go"
    elif [[ -f "pyproject.toml" ]] || [[ -f "requirements.txt" ]]; then
        main_language="python"
    elif [[ "$project_name" == "knowledge-management" ]] || [[ "$project_name" == "Claude" ]]; then
        main_language="shell"
    fi
    
    # Create session analysis
    cat > "$session_file" << EOF
{
  "session_id": "session_$(date +%Y%m%d_%H%M%S)",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "project": "$project_name",
  "working_directory": "$PWD",
  "main_language": "$main_language",
  "mode": "$([[ "$INTERACTIVE_MODE" == true ]] && echo "interactive" || echo "automatic")"
}
EOF
    
    echo "$session_file"
}

# Main execution
main() {
    echo -e "${PURPLE}ðŸ§  UKB - Update Knowledge Base v3.0${NC}"
    echo -e "${PURPLE}======================================${NC}"
    
    # Analyze session
    local session_file
    session_file=$(analyze_session)
    
    # Check if session file exists
    if [[ ! -f "$session_file" ]]; then
        error_exit "Failed to create session analysis"
    fi
    
    local project_name main_language
    project_name=$(jq -r '.project' "$session_file")
    main_language=$(jq -r '.main_language' "$session_file")
    
    # Process insights based on mode
    local insights_file="$TMP_DIR/insights.json"
    
    if [[ "$INTERACTIVE_MODE" == true ]]; then
        echo -e "${CYAN}ðŸŽ¯ Running in INTERACTIVE mode${NC}"
        echo '{"insights": [], "entities": [], "relations": []}' > "$insights_file"
        
        # Capture deep insight interactively
        capture_interactive_insight "$insights_file" "$project_name" "$main_language"
        
        # Ask if user wants to add more
        while true; do
            echo -e "\n${YELLOW}Add another insight? (y/n)${NC}"
            read -r -n 1 answer
            echo
            if [[ "$answer" != "y" ]]; then
                break
            fi
            capture_interactive_insight "$insights_file" "$project_name" "$main_language"
        done
    else
        echo -e "${CYAN}ðŸ¤– Running in AUTOMATIC mode${NC}"
        extract_auto_insights "$insights_file" "$project_name" "$main_language"
    fi
    
    # Create entities and relationships
    if [[ -f "$insights_file" ]] && [[ $(jq '.insights | length' "$insights_file") -gt 0 ]]; then
        create_mcp_entities "$insights_file"
        create_project_relationships
    else
        echo -e "${YELLOW}âš ï¸  No insights captured${NC}"
    fi
    
    # Update metadata
    local timestamp contributor
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    contributor=$(whoami)
    jq --arg contributor "$contributor" \
       --arg timestamp "$timestamp" \
       --arg mode "$([[ "$INTERACTIVE_MODE" == true ]] && echo "interactive" || echo "automatic")" \
       '.metadata.contributors |= (. + [$contributor] | unique) |
        .metadata.last_updated = $timestamp |
        .metadata.last_mode = $mode' \
       "$SHARED_MEMORY" > "$SHARED_MEMORY.tmp" && mv "$SHARED_MEMORY.tmp" "$SHARED_MEMORY"
    
    # Show summary
    show_insight_summary
    
    # Final stats
    local entity_count relation_count
    entity_count=$(jq '.entities | length' "$SHARED_MEMORY")
    relation_count=$(jq '.relations | length' "$SHARED_MEMORY")
    
    echo -e "\n${GREEN}âœ… Knowledge base updated successfully!${NC}"
    echo -e "${GREEN}ðŸ“Š Total entities: $entity_count${NC}"
    echo -e "${GREEN}ðŸ”— Total relations: $relation_count${NC}"
    echo -e "${GREEN}ðŸ’¾ Shared memory: $SHARED_MEMORY${NC}"
    
    log "UKB completed successfully"
}

# Parse arguments and run
parse_args "$@"
main