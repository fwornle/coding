#!/bin/bash
# VKB (View Knowledge Base) - Background visualization server manager
# Version 2.0 - Complete rewrite with proper server management

set -euo pipefail

# Configuration - Dynamic repo detection
# Find the repository root by looking for characteristic files/directories
find_repo_root() {
    local current_dir="$PWD"
    while [[ "$current_dir" != "/" ]]; do
        if [[ -f "$current_dir/shared-memory.json" ]] && [[ -d "$current_dir/knowledge-management" ]]; then
            echo "$current_dir"
            return 0
        fi
        current_dir="$(dirname "$current_dir")"
    done
    
    # Fallback: check common locations
    local common_paths=(
        "$HOME/Agentic/coding"
        "$HOME/coding"
        "$HOME/projects/coding"
        "$HOME/dev/coding"
    )
    
    for path in "${common_paths[@]}"; do
        if [[ -f "$path/shared-memory.json" ]] && [[ -d "$path/knowledge-management" ]]; then
            echo "$path"
            return 0
        fi
    done
    
    # Last resort: use current directory if it has the right structure  
    if [[ -f "shared-memory.json" ]] && [[ -d "knowledge-management" ]]; then
        echo "$PWD"
        return 0
    fi
    
    # Final fallback: return current directory or error
    if [[ -d "knowledge-management" ]]; then
        echo "$PWD"
    else
        echo "ERROR: Could not find repository root" >&2
        return 1
    fi
}

CODING_REPO="$(find_repo_root)"
if [[ "$CODING_REPO" == "ERROR:"* ]]; then
    error_exit "Could not find repository root. Please run from within the coding repository."
fi
SHARED_MEMORY="$CODING_REPO/shared-memory.json"
VISUALIZER_DIR="$CODING_REPO/memory-visualizer"
SERVER_PORT=8080
PID_FILE="/tmp/vkb-server.pid"
LOG_FILE="/tmp/vkb-server.log"

# Colors for output (with terminal support check)
if [[ -t 1 ]] && [[ "${TERM:-}" != "dumb" ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    # No colors if not in a terminal or terminal doesn't support colors
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# Error handling
error_exit() {
    echo -e "${RED}ERROR: $1${NC}" >&2
    exit 1
}

# Check if server is running
is_server_running() {
    # First check if our PID file exists and process is running
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            # Check if it's actually our server
            if command -v lsof >/dev/null 2>&1; then
                if lsof -i ":$SERVER_PORT" -t 2>/dev/null | grep -q "$pid"; then
                    return 0
                fi
            else
                # If lsof not available, just trust the PID file
                return 0
            fi
        fi
        # PID file is stale, remove it
        rm -f "$PID_FILE"
    fi
    
    # Also check if any process is listening on our port (could be orphaned server)
    # Try lsof first, then fall back to ss or netstat
    if command -v lsof >/dev/null 2>&1; then
        if lsof -i ":$SERVER_PORT" -sTCP:LISTEN >/dev/null 2>&1; then
            return 0
        fi
    elif command -v ss >/dev/null 2>&1; then
        if ss -tln 2>/dev/null | grep -q ":$SERVER_PORT "; then
            return 0
        fi
    elif command -v netstat >/dev/null 2>&1; then
        if netstat -tln 2>/dev/null | grep -q ":$SERVER_PORT "; then
            return 0
        fi
    fi
    
    return 1
}

# Stop existing server
stop_server() {
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "${YELLOW}Stopping existing server (PID: $pid)...${NC}"
            kill "$pid" 2>/dev/null || true
            sleep 2
            # Force kill if still running
            if kill -0 "$pid" 2>/dev/null; then
                kill -9 "$pid" 2>/dev/null || true
            fi
        fi
        rm -f "$PID_FILE"
    fi
    
    # Kill any process listening on our port
    local port_pid=""
    if command -v lsof >/dev/null 2>&1; then
        port_pid=$(lsof -i ":$SERVER_PORT" -sTCP:LISTEN -t 2>/dev/null || true)
    elif command -v ss >/dev/null 2>&1; then
        # Extract PID from ss output (Linux) - only listening ports
        port_pid=$(ss -tlnp 2>/dev/null | grep ":$SERVER_PORT " | grep -o 'pid=[0-9]*' | cut -d= -f2 || true)
    elif command -v netstat >/dev/null 2>&1; then
        # Try to extract PID from netstat (may require root) - only listening ports
        port_pid=$(netstat -tlnp 2>/dev/null | grep ":$SERVER_PORT " | awk '{print $7}' | cut -d'/' -f1 | grep -E '^[0-9]+$' || true)
    fi
    if [[ -n "$port_pid" ]]; then
        echo -e "${YELLOW}Killing process using port $SERVER_PORT (PID: $port_pid)...${NC}"
        kill "$port_pid" 2>/dev/null || true
        sleep 1
        if kill -0 "$port_pid" 2>/dev/null; then
            kill -9 "$port_pid" 2>/dev/null || true
        fi
    fi
}

# Prepare memory data for visualization
prepare_memory_data() {
    echo -e "${BLUE}üìä Preparing memory data for visualization...${NC}"
    
    # Ensure visualizer directory exists
    if [[ ! -d "$VISUALIZER_DIR" ]]; then
        error_exit "Memory visualizer directory not found: $VISUALIZER_DIR"
    fi
    
    # Check if shared memory file exists
    if [[ ! -f "$SHARED_MEMORY" ]]; then
        error_exit "Shared memory file not found: $SHARED_MEMORY"
    fi
    
    # Convert shared memory to visualizer format
    local memory_dist="$VISUALIZER_DIR/dist/memory.json"
    mkdir -p "$(dirname "$memory_dist")"
    
    # Create symlink to knowledge-management directory for serving documentation
    local km_link="$VISUALIZER_DIR/dist/knowledge-management"
    if [[ -L "$km_link" ]]; then
        # Remove existing symlink to recreate it (in case path changed)
        rm -f "$km_link"
    fi
    
    # Create fresh symlink
    if ln -sf "$CODING_REPO/knowledge-management" "$km_link" 2>/dev/null; then
        echo -e "${GREEN}‚úì Knowledge management files linked for serving${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Could not create symlink to knowledge-management directory${NC}"
        echo -e "${YELLOW}   Insight files may not be accessible${NC}"
    fi
    
    # Verify the symlink points to the right place
    if [[ -L "$km_link" ]] && [[ -d "$km_link/insights" ]]; then
        local insight_count
        insight_count=$(find "$km_link/insights" -name "*.md" 2>/dev/null | wc -l)
        echo -e "${GREEN}‚úì Found $insight_count insight files${NC}"
    fi
    
    # Convert from our format to NDJSON format expected by visualizer
    # Also deduplicate entities to prevent orphans and convert observations to simple strings
    {
        # Deduplicate entities by name (keep the latest one), add type field, and convert observations
        jq -r '.entities | group_by(.name) | map(max_by(.created // "2000-01-01")) | .[] | 
        (if .observations and (.observations | type == "array") and (.observations | length > 0) and (.observations[0] | type == "object") then
          .observations = (.observations | map(if type == "object" then .content else . end))
        else . end) |
        (if .legacy_observations and (.legacy_observations | length > 0) then
          .observations = .legacy_observations
        else . end) |
        . + {"type": "entity"} | @json' "$SHARED_MEMORY" 2>/dev/null || true
        jq -r '.relations[] | @json' "$SHARED_MEMORY" 2>/dev/null || true
    } > "$memory_dist"
    
    echo -e "${GREEN}‚úì Memory data prepared${NC}"
    local entity_count relation_count
    entity_count=$(jq '.entities | length' "$SHARED_MEMORY" 2>/dev/null || echo "0")
    relation_count=$(jq '.relations | length' "$SHARED_MEMORY" 2>/dev/null || echo "0")
    echo -e "${GREEN}üìä Entities: $entity_count, Relations: $relation_count${NC}"
}

# Start visualization server
start_server() {
    local foreground_mode="${1:-false}"
    echo -e "${BLUE}üöÄ Starting visualization server...${NC}"
    
    # Check for Python 3
    if ! command -v python3 >/dev/null 2>&1; then
        error_exit "Python 3 is required but not found. Please install Python 3."
    fi
    
    # Change to visualizer directory
    cd "$VISUALIZER_DIR"
    
    # Choose server type based on availability
    local server_cmd
    if [[ -f "$VISUALIZER_DIR/cors-server.py" ]]; then
        server_cmd="python3 $VISUALIZER_DIR/cors-server.py $SERVER_PORT dist"
        echo -e "${GREEN}‚úì Using CORS-enabled server${NC}"
    else
        server_cmd="python3 -m http.server $SERVER_PORT --directory dist"
        echo -e "${YELLOW}‚ö†Ô∏è  Using basic HTTP server (CORS issues may occur)${NC}"
    fi
    
    if [[ "$foreground_mode" == "true" ]]; then
        # Start HTTP server in foreground for debugging
        echo -e "${YELLOW}üîç Running in foreground mode (press Ctrl+C to stop)${NC}"
        echo -e "${GREEN}üîó URL: http://localhost:$SERVER_PORT${NC}"
        echo -e "${BLUE}üìä Server output:${NC}"
        echo "----------------------------------------"
        exec $server_cmd
    else
        # Start HTTP server in background
        {
            $server_cmd 2>&1 | \
            while IFS= read -r line; do
                echo "$(date '+%Y-%m-%d %H:%M:%S') $line"
            done
        } > "$LOG_FILE" 2>&1 &
        
        local server_pid=$!
        echo "$server_pid" > "$PID_FILE"
        
        # Wait a moment and check if server started successfully
        sleep 2
        if ! kill -0 "$server_pid" 2>/dev/null; then
            rm -f "$PID_FILE"
            error_exit "Failed to start visualization server. Check $LOG_FILE for details."
        fi
        
        # Verify server is responding
        local max_attempts=10
        local attempt=1
        while (( attempt <= max_attempts )); do
            if curl -s "http://localhost:$SERVER_PORT" >/dev/null 2>&1; then
                break
            fi
            if (( attempt == max_attempts )); then
                stop_server
                error_exit "Server failed to respond after $max_attempts attempts"
            fi
            sleep 1
            ((attempt++))
        done
        
        echo -e "${GREEN}‚úÖ Visualization server started successfully!${NC}"
        echo -e "${GREEN}üåê Server PID: $server_pid${NC}"
        echo -e "${GREEN}üîó URL: http://localhost:$SERVER_PORT${NC}"
        echo -e "${GREEN}üìÑ Logs: $LOG_FILE${NC}"
    fi
}

# Open browser (optional)
open_browser() {
    if command -v open >/dev/null 2>&1; then
        echo -e "${BLUE}üåê Opening browser...${NC}"
        open "http://localhost:$SERVER_PORT" 2>/dev/null || true
    elif command -v xdg-open >/dev/null 2>&1; then
        echo -e "${BLUE}üåê Opening browser...${NC}"
        xdg-open "http://localhost:$SERVER_PORT" 2>/dev/null || true
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Could not open browser automatically${NC}"
        echo -e "${YELLOW}Please open: http://localhost:$SERVER_PORT${NC}"
    fi
}

# Show server status
show_status() {
    if is_server_running; then
        echo -e "${GREEN}‚úÖ Visualization server is running${NC}"
        if [[ -f "$PID_FILE" ]]; then
            local pid
            pid=$(cat "$PID_FILE")
            echo -e "${GREEN}üåê PID: $pid${NC}"
        else
            echo -e "${GREEN}üåê PID: Unknown (server detected on port)${NC}"
        fi
        echo -e "${GREEN}üîó URL: http://localhost:$SERVER_PORT${NC}"
        echo -e "${GREEN}üìÑ Logs: $LOG_FILE${NC}"
    else
        echo -e "${RED}‚ùå Visualization server is not running${NC}"
    fi
}

# Check dependencies
check_dependencies() {
    local missing_deps=()
    
    if ! command -v jq >/dev/null 2>&1; then
        missing_deps+=("jq")
    fi
    
    if ! command -v python3 >/dev/null 2>&1; then
        missing_deps+=("python3")
    fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        error_exit "Missing required dependencies: ${missing_deps[*]}. Please install them first."
    fi
}

# Main execution
main() {
    local command="${1:-start}"
    
    # Check dependencies before running any command
    if [[ "$command" != "help" ]] && [[ "$command" != "--help" ]] && [[ "$command" != "-h" ]]; then
        check_dependencies
    fi
    
    case "$command" in
        "start"|"")
            echo -e "${BLUE}üîç VKB - View Knowledge Base v2.0${NC}"
            echo -e "${BLUE}=====================================${NC}"
            
            if is_server_running; then
                echo -e "${YELLOW}‚ö†Ô∏è  Server already running${NC}"
                echo -e "${BLUE}üìä Refreshing memory data...${NC}"
                prepare_memory_data
                show_status
                open_browser
                echo -e "${GREEN}‚úÖ Data refreshed for existing server${NC}"
                return 0
            fi
            
            # Prepare data and start server
            prepare_memory_data
            start_server
            open_browser
            
            echo -e "${BLUE}üí° Server running in background. Use 'vkb stop' to stop it.${NC}"
            ;;
        "fg"|"foreground")
            echo -e "${BLUE}üîç VKB - View Knowledge Base v2.0 (Foreground Mode)${NC}"
            echo -e "${BLUE}=====================================${NC}"
            
            if is_server_running; then
                echo -e "${YELLOW}‚ö†Ô∏è  Server already running in background${NC}"
                echo -e "${YELLOW}Please stop it first with 'vkb stop'${NC}"
                return 1
            fi
            
            # Prepare data and start server in foreground
            prepare_memory_data
            open_browser
            start_server true  # Pass true for foreground mode
            ;;
        "stop")
            echo -e "${BLUE}üõë Stopping visualization server...${NC}"
            stop_server
            echo -e "${GREEN}‚úÖ Server stopped${NC}"
            ;;
        "restart")
            echo -e "${BLUE}üîÑ Restarting visualization server...${NC}"
            stop_server
            prepare_memory_data
            start_server
            open_browser
            echo -e "${GREEN}‚úÖ Server restarted${NC}"
            ;;
        "status")
            show_status
            ;;
        "logs")
            if [[ -f "$LOG_FILE" ]]; then
                echo -e "${BLUE}üìÑ Server logs:${NC}"
                tail -n 20 "$LOG_FILE"
            else
                echo -e "${YELLOW}‚ö†Ô∏è  No log file found${NC}"
            fi
            ;;
        "help"|"--help"|"-h"|*)
            echo "Usage: $0 [start|fg|stop|restart|status|logs|help]"
            echo "  start      - Start visualization server in background (default)"  
            echo "  fg         - Start visualization server in foreground (for debugging)"
            echo "  foreground - Same as 'fg'"
            echo "  stop       - Stop visualization server"
            echo "  restart    - Restart visualization server"
            echo "  status     - Show server status"
            echo "  logs       - Show recent server logs"
            echo "  help       - Show this help message"
            echo ""
            echo "Foreground mode is useful for debugging as it shows server output directly."
            echo "Press Ctrl+C to stop the server when running in foreground mode."
            echo ""
            echo "Requirements:"
            echo "  - jq (JSON processor)"
            echo "  - python3 (for HTTP server)"
            echo "  - lsof/ss/netstat (for port checking, at least one required)"
            if [[ "$command" != "help" ]] && [[ "$command" != "--help" ]] && [[ "$command" != "-h" ]]; then
                exit 1
            fi
            ;;
    esac
}

# Execute main function
main "$@"