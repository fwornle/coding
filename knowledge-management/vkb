#!/bin/bash
# VKB (View Knowledge Base) - Background visualization server manager
# Version 2.0 - Complete rewrite with proper server management

set -euo pipefail

# Configuration - Dynamic repo detection
# Find the repository root by looking for characteristic files/directories
find_repo_root() {
    local current_dir="$PWD"
    while [[ "$current_dir" != "/" ]]; do
        if [[ -f "$current_dir/shared-memory.json" ]] && [[ -d "$current_dir/knowledge-management" ]]; then
            echo "$current_dir"
            return 0
        fi
        current_dir="$(dirname "$current_dir")"
    done
    
    # Fallback: check common locations
    local common_paths=(
        "$HOME/Agentic/coding"
        "$HOME/coding"
        "$HOME/projects/coding"
        "$HOME/dev/coding"
    )
    
    for path in "${common_paths[@]}"; do
        if [[ -f "$path/shared-memory.json" ]] && [[ -d "$path/knowledge-management" ]]; then
            echo "$path"
            return 0
        fi
    done
    
    # Last resort: use current directory if it has the right structure  
    if [[ -f "shared-memory.json" ]] && [[ -d "knowledge-management" ]]; then
        echo "$PWD"
        return 0
    fi
    
    # Final fallback: return current directory or error
    if [[ -d "knowledge-management" ]]; then
        echo "$PWD"
    else
        echo "ERROR: Could not find repository root" >&2
        return 1
    fi
}

CODING_REPO="$(find_repo_root)"
if [[ "$CODING_REPO" == "ERROR:"* ]]; then
    error_exit "Could not find repository root. Please run from within the coding repository."
fi
SHARED_MEMORY="$CODING_REPO/shared-memory.json"
VISUALIZER_DIR="/Users/q284340/Agentic/coding/memory-visualizer"
SERVER_PORT=8080
PID_FILE="/tmp/vkb-server.pid"
LOG_FILE="/tmp/vkb-server.log"

# Colors for output (with terminal support check)
if [[ -t 1 ]] && [[ "${TERM:-}" != "dumb" ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    # No colors if not in a terminal or terminal doesn't support colors
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# Error handling
error_exit() {
    echo -e "${RED}ERROR: $1${NC}" >&2
    exit 1
}

# Check if server is running
is_server_running() {
    # First check if our PID file exists and process is running
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            # Check if it's actually our server
            if command -v lsof >/dev/null 2>&1; then
                if lsof -i ":$SERVER_PORT" -t 2>/dev/null | grep -q "$pid"; then
                    return 0
                fi
            else
                # If lsof not available, just trust the PID file
                return 0
            fi
        fi
        # PID file is stale, remove it
        rm -f "$PID_FILE"
    fi
    
    # Also check if any process is listening on our port (could be orphaned server)
    # Try lsof first, then fall back to ss or netstat
    if command -v lsof >/dev/null 2>&1; then
        if lsof -i ":$SERVER_PORT" -sTCP:LISTEN >/dev/null 2>&1; then
            return 0
        fi
    elif command -v ss >/dev/null 2>&1; then
        if ss -tln 2>/dev/null | grep -q ":$SERVER_PORT "; then
            return 0
        fi
    elif command -v netstat >/dev/null 2>&1; then
        if netstat -tln 2>/dev/null | grep -q ":$SERVER_PORT "; then
            return 0
        fi
    fi
    
    return 1
}

# Stop existing server
stop_server() {
    # First, try to stop using PID file
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "${YELLOW}Stopping existing server (PID: $pid)...${NC}"
            kill "$pid" 2>/dev/null || true
            sleep 1
            # Force kill if still running
            if kill -0 "$pid" 2>/dev/null; then
                kill -9 "$pid" 2>/dev/null || true
            fi
        fi
        rm -f "$PID_FILE"
    fi
    
    # Kill ALL processes listening on our port (handle multiple instances)
    local max_attempts=5
    local attempt=1
    
    while [[ $attempt -le $max_attempts ]]; do
        local port_pids=""
        if command -v lsof >/dev/null 2>&1; then
            # Get all PIDs using the port
            port_pids=$(lsof -ti:$SERVER_PORT 2>/dev/null || true)
        fi
        
        if [[ -z "$port_pids" ]]; then
            # Port is free
            break
        fi
        
        echo -e "${YELLOW}Attempt $attempt/$max_attempts: Killing processes using port $SERVER_PORT (PIDs: $(echo $port_pids | tr '\n' ' '))...${NC}"
        
        # Kill all processes
        for pid in $port_pids; do
            kill "$pid" 2>/dev/null || true
        done
        
        sleep 1
        
        # Force kill if still running
        for pid in $port_pids; do
            if kill -0 "$pid" 2>/dev/null; then
                kill -9 "$pid" 2>/dev/null || true
            fi
        done
        
        # Wait for OS to release the port
        sleep 2
        
        attempt=$((attempt + 1))
    done
    
    # Final check
    if command -v lsof >/dev/null 2>&1; then
        if lsof -i:$SERVER_PORT >/dev/null 2>&1; then
            echo -e "${RED}âš ï¸  Warning: Port $SERVER_PORT may still be in use${NC}"
        fi
    fi
}

# Prepare memory data for visualization
prepare_memory_data() {
    echo -e "${BLUE}ðŸ“Š Preparing memory data for visualization...${NC}"
    
    # Ensure visualizer directory exists
    if [[ ! -d "$VISUALIZER_DIR" ]]; then
        error_exit "Memory visualizer directory not found: $VISUALIZER_DIR"
    fi
    
    # Check if shared memory file exists
    if [[ ! -f "$SHARED_MEMORY" ]]; then
        error_exit "Shared memory file not found: $SHARED_MEMORY"
    fi
    
    # Convert shared memory to visualizer format
    local memory_dist="$VISUALIZER_DIR/dist/memory.json"
    mkdir -p "$(dirname "$memory_dist")"
    
    # Create symlink to knowledge-management directory for serving documentation
    local km_link="$VISUALIZER_DIR/dist/knowledge-management"
    if [[ -L "$km_link" ]]; then
        # Remove existing symlink to recreate it (in case path changed)
        rm -f "$km_link"
    fi
    
    # Create fresh symlink
    if ln -sf "$CODING_REPO/knowledge-management" "$km_link" 2>/dev/null; then
        echo -e "${GREEN}âœ“ Knowledge management files linked for serving${NC}"
    else
        echo -e "${YELLOW}âš ï¸  Could not create symlink to knowledge-management directory${NC}"
        echo -e "${YELLOW}   Insight files may not be accessible${NC}"
    fi
    
    # Verify the symlink points to the right place
    if [[ -L "$km_link" ]] && [[ -d "$km_link/insights" ]]; then
        local insight_count
        insight_count=$(find "$km_link/insights" -name "*.md" 2>/dev/null | wc -l)
        echo -e "${GREEN}âœ“ Found $insight_count insight files${NC}"
    fi
    
    # Check if ukb has already generated the NDJSON file
    if [[ -f "$memory_dist" ]]; then
        echo -e "${GREEN}âœ“ Using existing NDJSON data (managed by ukb)${NC}"
    else
        # Fallback: Convert from shared-memory.json if ukb hasn't run yet
        local temp_file="${memory_dist}.tmp"
        {
            # Convert to NDJSON format expected by visualizer
            jq -r '.entities | group_by(.name) | map(max_by(.created // "2000-01-01")) | .[] | 
            (if .observations and (.observations | type == "array") and (.observations | length > 0) and (.observations[0] | type == "object") then
              .observations = (.observations | map(if type == "object" then .content else . end))
            else . end) |
            (if .legacy_observations and (.legacy_observations | length > 0) then
              .observations = .legacy_observations
            else . end) |
            . + {"type": "entity"} | @json' "$SHARED_MEMORY" 2>/dev/null || true
            jq -r '.relations[] | @json' "$SHARED_MEMORY" 2>/dev/null || true
        } > "$temp_file" && mv -f "$temp_file" "$memory_dist"
    fi
    
    echo -e "${GREEN}âœ“ Memory data prepared${NC}"
    local entity_count relation_count
    entity_count=$(jq '.entities | length' "$SHARED_MEMORY" 2>/dev/null || echo "0")
    relation_count=$(jq '.relations | length' "$SHARED_MEMORY" 2>/dev/null || echo "0")
    echo -e "${GREEN}ðŸ“Š Entities: $entity_count, Relations: $relation_count${NC}"
}

# Start visualization server
start_server() {
    local foreground_mode="${1:-false}"
    echo -e "${BLUE}ðŸš€ Starting visualization server...${NC}"
    
    # Check for Python 3
    if ! command -v python3 >/dev/null 2>&1; then
        error_exit "Python 3 is required but not found. Please install Python 3."
    fi
    
    # Change to visualizer directory
    cd "$VISUALIZER_DIR"
    
    # Choose server type based on availability
    local server_cmd
    if [[ -f "$VISUALIZER_DIR/cors-server.py" ]]; then
        server_cmd="python3 $VISUALIZER_DIR/cors-server.py $SERVER_PORT dist"
        echo -e "${GREEN}âœ“ Using CORS-enabled server${NC}"
    else
        server_cmd="python3 -m http.server $SERVER_PORT --directory dist"
        echo -e "${YELLOW}âš ï¸  Using basic HTTP server (CORS issues may occur)${NC}"
    fi
    
    if [[ "$foreground_mode" == "true" ]]; then
        # Start HTTP server in foreground for debugging
        echo -e "${YELLOW}ðŸ” Running in foreground mode (press Ctrl+C to stop)${NC}"
        echo -e "${GREEN}ðŸ”— URL: http://localhost:$SERVER_PORT${NC}"
        echo -e "${BLUE}ðŸ“Š Server output:${NC}"
        echo "----------------------------------------"
        exec $server_cmd
    else
        # Start HTTP server in background
        {
            $server_cmd 2>&1 | \
            while IFS= read -r line; do
                echo "$(date '+%Y-%m-%d %H:%M:%S') $line"
            done
        } > "$LOG_FILE" 2>&1 &
        
        local server_pid=$!
        echo "$server_pid" > "$PID_FILE"
        
        # Wait a moment and check if server started successfully
        sleep 2
        if ! kill -0 "$server_pid" 2>/dev/null; then
            rm -f "$PID_FILE"
            error_exit "Failed to start visualization server. Check $LOG_FILE for details."
        fi
        
        # Verify server is responding
        local max_attempts=10
        local attempt=1
        while (( attempt <= max_attempts )); do
            if curl -s "http://localhost:$SERVER_PORT" >/dev/null 2>&1; then
                break
            fi
            if (( attempt == max_attempts )); then
                stop_server
                error_exit "Server failed to respond after $max_attempts attempts"
            fi
            sleep 1
            ((attempt++))
        done
        
        echo -e "${GREEN}âœ… Visualization server started successfully!${NC}"
        echo -e "${GREEN}ðŸŒ Server PID: $server_pid${NC}"
        echo -e "${GREEN}ðŸ”— URL: http://localhost:$SERVER_PORT${NC}"
        echo -e "${GREEN}ðŸ“„ Logs: $LOG_FILE${NC}"
    fi
}

# Clear Chrome cache for localhost:8080
clear_chrome_cache() {
    echo -e "${BLUE}ðŸ—‘ï¸  Clearing Chrome cache for localhost:8080...${NC}"
    
    # macOS Chrome cache clearing
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # Try to close Chrome first (optional)
        osascript -e 'tell application "Google Chrome" to quit' 2>/dev/null || true
        sleep 1
        
        # Clear Chrome cache directories
        local cache_dirs=(
            "$HOME/Library/Caches/Google/Chrome/Default/Cache"
            "$HOME/Library/Caches/Google/Chrome/Default/Code Cache"
            "$HOME/Library/Application Support/Google/Chrome/Default/Local Storage"
            "$HOME/Library/Application Support/Google/Chrome/Default/Session Storage"
        )
        
        for cache_dir in "${cache_dirs[@]}"; do
            if [[ -d "$cache_dir" ]]; then
                echo -e "${YELLOW}   Clearing: $(basename "$cache_dir")${NC}"
                rm -rf "$cache_dir"/* 2>/dev/null || true
            fi
        done
        
        echo -e "${GREEN}âœ… Chrome cache cleared${NC}"
    else
        # Linux Chrome cache clearing
        local chrome_config_dir="$HOME/.config/google-chrome/Default"
        local cache_dirs=(
            "$chrome_config_dir/Cache"
            "$chrome_config_dir/Code Cache"
            "$HOME/.cache/google-chrome/Default"
        )
        
        for cache_dir in "${cache_dirs[@]}"; do
            if [[ -d "$cache_dir" ]]; then
                echo -e "${YELLOW}   Clearing: $(basename "$cache_dir")${NC}"
                rm -rf "$cache_dir"/* 2>/dev/null || true
            fi
        done
        
        echo -e "${GREEN}âœ… Chrome cache cleared${NC}"
    fi
}

# Open browser (optional)
open_browser() {
    if command -v open >/dev/null 2>&1; then
        echo -e "${BLUE}ðŸŒ Opening browser...${NC}"
        open "http://localhost:$SERVER_PORT" 2>/dev/null || true
    elif command -v xdg-open >/dev/null 2>&1; then
        echo -e "${BLUE}ðŸŒ Opening browser...${NC}"
        xdg-open "http://localhost:$SERVER_PORT" 2>/dev/null || true
    else
        echo -e "${YELLOW}âš ï¸  Could not open browser automatically${NC}"
        echo -e "${YELLOW}Please open: http://localhost:$SERVER_PORT${NC}"
    fi
}

# Show server status
show_status() {
    if is_server_running; then
        echo -e "${GREEN}âœ… Visualization server is running${NC}"
        if [[ -f "$PID_FILE" ]]; then
            local pid
            pid=$(cat "$PID_FILE")
            echo -e "${GREEN}ðŸŒ PID: $pid${NC}"
        else
            echo -e "${GREEN}ðŸŒ PID: Unknown (server detected on port)${NC}"
        fi
        echo -e "${GREEN}ðŸ”— URL: http://localhost:$SERVER_PORT${NC}"
        echo -e "${GREEN}ðŸ“„ Logs: $LOG_FILE${NC}"
    else
        echo -e "${RED}âŒ Visualization server is not running${NC}"
    fi
}

# Check dependencies
check_dependencies() {
    local missing_deps=()
    
    if ! command -v jq >/dev/null 2>&1; then
        missing_deps+=("jq")
    fi
    
    if ! command -v python3 >/dev/null 2>&1; then
        missing_deps+=("python3")
    fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        error_exit "Missing required dependencies: ${missing_deps[*]}. Please install them first."
    fi
}

# Main execution
main() {
    local command="${1:-start}"
    local clear_cache=false
    
    # Check for cache clearing flag
    if [[ "${2:-}" == "--with-cache-clear" ]] || [[ "${1:-}" == "--with-cache-clear" ]]; then
        clear_cache=true
        if [[ "${1:-}" == "--with-cache-clear" ]]; then
            command="start"
        fi
    fi
    
    # Check dependencies before running any command
    if [[ "$command" != "help" ]] && [[ "$command" != "--help" ]] && [[ "$command" != "-h" ]]; then
        check_dependencies
    fi
    
    case "$command" in
        "start"|"")
            echo -e "${BLUE}ðŸ” VKB - View Knowledge Base v2.0${NC}"
            echo -e "${BLUE}=====================================${NC}"
            
            # Clear cache if requested
            if [[ "$clear_cache" == "true" ]]; then
                clear_chrome_cache
            fi
            
            if is_server_running; then
                echo -e "${YELLOW}âš ï¸  Server already running${NC}"
                echo -e "${BLUE}ðŸ“Š Refreshing memory data...${NC}"
                prepare_memory_data
                show_status
                open_browser
                echo -e "${GREEN}âœ… Data refreshed for existing server${NC}"
                return 0
            fi
            
            # Prepare data and start server
            prepare_memory_data
            start_server
            open_browser
            
            echo -e "${BLUE}ðŸ’¡ Server running in background. Use 'vkb stop' to stop it.${NC}"
            ;;
        "fg"|"foreground")
            echo -e "${BLUE}ðŸ” VKB - View Knowledge Base v2.0 (Foreground Mode)${NC}"
            echo -e "${BLUE}=====================================${NC}"
            
            if is_server_running; then
                echo -e "${YELLOW}âš ï¸  Server already running in background${NC}"
                echo -e "${YELLOW}Please stop it first with 'vkb stop'${NC}"
                echo -e "${BLUE}Attempting to stop existing server...${NC}"
                stop_server
                sleep 2
            fi
            
            # Prepare data and start server in foreground
            prepare_memory_data
            open_browser
            start_server true  # Pass true for foreground mode
            ;;
        "stop")
            echo -e "${BLUE}ðŸ›‘ Stopping visualization server...${NC}"
            stop_server
            echo -e "${GREEN}âœ… Server stopped${NC}"
            ;;
        "restart")
            echo -e "${BLUE}ðŸ”„ Restarting visualization server...${NC}"
            stop_server
            
            # Clear cache if requested
            if [[ "$clear_cache" == "true" ]]; then
                clear_chrome_cache
            fi
            
            prepare_memory_data
            start_server
            open_browser
            echo -e "${GREEN}âœ… Server restarted${NC}"
            ;;
        "--clear-cache"|"clear-cache")
            echo -e "${BLUE}ðŸ—‘ï¸  Clearing Chrome cache only...${NC}"
            clear_chrome_cache
            echo -e "${GREEN}âœ… Cache cleared. Run 'vkb start' to view updated knowledge base.${NC}"
            ;;
        "status")
            show_status
            ;;
        "logs")
            if [[ -f "$LOG_FILE" ]]; then
                echo -e "${BLUE}ðŸ“„ Server logs:${NC}"
                tail -n 20 "$LOG_FILE"
            else
                echo -e "${YELLOW}âš ï¸  No log file found${NC}"
            fi
            ;;
        "port"|"check-port")
            echo -e "${BLUE}ðŸ” Checking port $SERVER_PORT usage:${NC}"
            echo
            
            # Check for listening servers
            echo -e "${BLUE}Listening servers on port $SERVER_PORT:${NC}"
            if command -v lsof >/dev/null 2>&1; then
                lsof -i ":$SERVER_PORT" -sTCP:LISTEN 2>/dev/null || echo "None found"
            elif command -v ss >/dev/null 2>&1; then
                ss -tlnp 2>/dev/null | grep ":$SERVER_PORT " || echo "None found"
            elif command -v netstat >/dev/null 2>&1; then
                netstat -tlnp 2>/dev/null | grep ":$SERVER_PORT " || echo "None found"
            else
                echo "No port checking tools available"
            fi
            
            echo
            echo -e "${BLUE}All connections involving port $SERVER_PORT:${NC}"
            if command -v lsof >/dev/null 2>&1; then
                lsof -i ":$SERVER_PORT" 2>/dev/null || echo "None found"
            elif command -v ss >/dev/null 2>&1; then
                ss -anp 2>/dev/null | grep ":$SERVER_PORT" || echo "None found"
            elif command -v netstat >/dev/null 2>&1; then
                netstat -anp 2>/dev/null | grep ":$SERVER_PORT" || echo "None found"
            else
                echo "No port checking tools available"
            fi
            ;;
        "help"|"--help"|"-h"|*)
            echo "Usage: $0 [start|fg|stop|restart|status|logs|port|clear-cache|help] [--with-cache-clear]"
            echo "  start      - Start visualization server in background (default)"  
            echo "  fg         - Start visualization server in foreground (for debugging)"
            echo "  foreground - Same as 'fg'"
            echo "  stop       - Stop visualization server"
            echo "  restart    - Restart visualization server"
            echo "  status     - Show server status"
            echo "  logs       - Show recent server logs"
            echo "  port       - Check what's using port 8080"
            echo "  clear-cache - Clear Chrome cache for localhost:8080 (helps with stale data)"
            echo "  help       - Show this help message"
            echo ""
            echo "Options:"
            echo "  --with-cache-clear - Clear Chrome cache before starting/restarting server"
            echo ""
            echo "Examples:"
            echo "  $0 start --with-cache-clear  # Start server and clear cache"
            echo "  $0 restart --with-cache-clear # Restart server and clear cache"
            echo "  $0 clear-cache               # Clear cache only"
            echo ""
            echo "Foreground mode is useful for debugging as it shows server output directly."
            echo "Press Ctrl+C to stop the server when running in foreground mode."
            echo ""
            echo "Requirements:"
            echo "  - jq (JSON processor)"
            echo "  - python3 (for HTTP server)"
            echo "  - lsof/ss/netstat (for port checking, at least one required)"
            if [[ "$command" != "help" ]] && [[ "$command" != "--help" ]] && [[ "$command" != "-h" ]]; then
                exit 1
            fi
            ;;
    esac
}

# Execute main function
main "$@"