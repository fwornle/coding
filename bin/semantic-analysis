#!/usr/bin/env node

/**
 * Global Semantic Analysis Launcher
 * 
 * This script allows running semantic analysis from any directory.
 * It locates the semantic-analysis-system and executes it with proper context.
 */

import { spawn } from 'child_process';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';
import { existsSync } from 'fs';
import process from 'process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Find the semantic analysis system
const POSSIBLE_LOCATIONS = [
  // Relative to this bin directory
  join(__dirname, '..', 'semantic-analysis-system'),
  // In coding directory
  join(__dirname, '..', '..', 'coding', 'semantic-analysis-system'),
  // Global installation
  join(process.env.HOME, '.agentic', 'semantic-analysis-system'),
  // Environment variable override
  process.env.SEMANTIC_ANALYSIS_PATH
].filter(Boolean);

function findSemanticAnalysisSystem() {
  for (const location of POSSIBLE_LOCATIONS) {
    const indexPath = join(location, 'index.js');
    if (existsSync(indexPath)) {
      return location;
    }
  }
  
  console.error('âŒ Semantic Analysis System not found!');
  console.error('Searched locations:');
  POSSIBLE_LOCATIONS.forEach(loc => console.error(`  - ${loc}`));
  console.error('\nPlease ensure the semantic-analysis-system is installed.');
  process.exit(1);
}

async function killStaleProcesses() {
  console.log('ðŸ” Checking for stale semantic-analysis processes...');
  
  try {
    const { execSync } = await import('child_process');
    
    // Kill any existing semantic-analysis processes
    try {
      execSync('pkill -f "semantic-analysis-system" || true', { stdio: 'pipe' });
      console.log('âœ… Cleaned up stale processes');
    } catch (e) {
      // pkill returns non-zero if no processes found, which is fine
    }
    
    // Give processes time to exit
    await new Promise(resolve => setTimeout(resolve, 1000));
  } catch (error) {
    console.error('âš ï¸  Failed to clean up processes:', error.message);
  }
}

async function checkPortAvailability() {
  const requiredPorts = [1883, 8080, 8081, 9090];
  const unavailablePorts = [];
  
  for (const port of requiredPorts) {
    try {
      const { createServer } = await import('net');
      const server = createServer();
      
      await new Promise((resolve, reject) => {
        server.once('error', (err) => {
          if (err.code === 'EADDRINUSE') {
            reject(err);
          } else {
            reject(err);
          }
        });
        
        server.listen(port, () => {
          server.close(() => resolve());
        });
      });
    } catch (error) {
      if (error.code === 'EADDRINUSE') {
        unavailablePorts.push(port);
      }
    }
  }
  
  if (unavailablePorts.length > 0) {
    console.error('âŒ Port conflicts detected after cleanup:');
    unavailablePorts.forEach(port => {
      console.error(`  - Port ${port} is still in use`);
    });
    console.error('\nðŸ’¡ This may be due to non-semantic-analysis processes.');
    console.error('Please manually check what is using these ports.');
    process.exit(1);
  }
  
  console.log('âœ… All required ports are available');
}

async function runSemanticAnalysis() {
  // Kill stale processes first
  await killStaleProcesses();
  
  // Then check port availability
  await checkPortAvailability();
  
  const systemPath = findSemanticAnalysisSystem();
  const indexPath = join(systemPath, 'index.js');
  
  console.log(`ðŸš€ Starting Semantic Analysis System from: ${systemPath}`);
  console.log(`ðŸ“ Current working directory: ${process.cwd()}`);
  
  // Spawn the process with proper environment
  const child = spawn('node', [indexPath, ...process.argv.slice(2)], {
    cwd: systemPath,
    stdio: 'inherit',
    env: {
      ...process.env,
      SEMANTIC_ANALYSIS_CWD: process.cwd(), // Pass original working directory
      SEMANTIC_ANALYSIS_SYSTEM_PATH: systemPath
    }
  });
  
  child.on('close', (code) => {
    process.exit(code);
  });
  
  child.on('error', (error) => {
    console.error('âŒ Failed to start semantic analysis:', error.message);
    process.exit(1);
  });
}

// Handle process signals
process.on('SIGINT', () => {
  console.log('\nðŸ›‘ Semantic Analysis interrupted');
  process.exit(0);
});

process.on('SIGTERM', () => {
  console.log('\nðŸ›‘ Semantic Analysis terminated');
  process.exit(0);
});

runSemanticAnalysis();