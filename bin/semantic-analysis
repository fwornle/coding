#!/usr/bin/env node

/**
 * Global Semantic Analysis Launcher
 * 
 * This script allows running semantic analysis from any directory.
 * It locates the semantic-analysis-system and executes it with proper context.
 */

import { spawn } from 'child_process';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';
import { existsSync } from 'fs';
import process from 'process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Find the semantic analysis system
const POSSIBLE_LOCATIONS = [
  // Relative to this bin directory
  join(__dirname, '..', 'semantic-analysis-system'),
  // In coding directory
  join(__dirname, '..', '..', 'coding', 'semantic-analysis-system'),
  // Global installation
  join(process.env.HOME, '.agentic', 'semantic-analysis-system'),
  // Environment variable override
  process.env.SEMANTIC_ANALYSIS_PATH
].filter(Boolean);

function findSemanticAnalysisSystem() {
  for (const location of POSSIBLE_LOCATIONS) {
    const indexPath = join(location, 'index.js');
    if (existsSync(indexPath)) {
      return location;
    }
  }
  
  console.error('âŒ Semantic Analysis System not found!');
  console.error('Searched locations:');
  POSSIBLE_LOCATIONS.forEach(loc => console.error(`  - ${loc}`));
  console.error('\nPlease ensure the semantic-analysis-system is installed.');
  process.exit(1);
}

async function killStaleProcesses() {
  console.log('ðŸ” Checking for stale semantic-analysis processes...');
  
  try {
    const { execSync } = await import('child_process');
    
    // Kill any existing semantic-analysis processes
    try {
      execSync('pkill -f "semantic-analysis-system" || true', { stdio: 'pipe' });
      console.log('âœ… Cleaned up stale processes');
    } catch (e) {
      // pkill returns non-zero if no processes found, which is fine
    }
    
    // Give processes time to exit
    await new Promise(resolve => setTimeout(resolve, 1000));
  } catch (error) {
    console.error('âš ï¸  Failed to clean up processes:', error.message);
  }
}

async function checkPortAvailability() {
  const requiredPorts = [1883, 8080, 8081, 9090];
  
  // Import our enhanced port manager
  const { CentralPortManager } = await import('../lib/services/port-manager.js');
  const portManager = new CentralPortManager();
  
  console.log('ðŸ” Checking port availability with service awareness...');
  
  const conflicts = [];
  const ourServices = [];
  const available = [];
  
  for (const port of requiredPorts) {
    const knownService = portManager.isKnownService(port);
    
    if (knownService) {
      console.log(`âœ… Port ${port} is used by our registered service: ${knownService}`);
      ourServices.push({ port, service: knownService });
    } else {
      const isAvailable = await portManager.isPortAvailable(port);
      
      if (isAvailable) {
        available.push(port);
      } else {
        const portUser = portManager.getPortUser(port);
        if (portUser && portManager.isOurService(portUser)) {
          console.log(`âœ… Port ${port} is used by our own process: ${portUser.process} (PID: ${portUser.pid})`);
          ourServices.push({ port, service: portUser.process });
        } else {
          conflicts.push({ port, user: portUser });
        }
      }
    }
  }
  
  if (conflicts.length > 0) {
    console.error('âŒ External port conflicts detected:');
    conflicts.forEach(({ port, user }) => {
      const userInfo = user ? `${user.process} (PID: ${user.pid})` : 'unknown process';
      console.error(`  - Port ${port} is used by: ${userInfo}`);
    });
    console.error('\nðŸ’¡ These are NOT our services. Manual resolution required.');
    process.exit(1);
  }
  
  console.log('âœ… Port check completed successfully');
  console.log(`   Our services: ${ourServices.length}`);
  console.log(`   Available ports: ${available.length}`);
  console.log(`   External conflicts: ${conflicts.length}`);
}

async function runSemanticAnalysis() {
  // Kill stale processes first
  await killStaleProcesses();
  
  // Then check port availability
  await checkPortAvailability();
  
  const systemPath = findSemanticAnalysisSystem();
  const indexPath = join(systemPath, 'index.js');
  
  console.log(`ðŸš€ Starting Semantic Analysis System from: ${systemPath}`);
  console.log(`ðŸ“ Current working directory: ${process.cwd()}`);
  
  // Spawn the process with proper environment
  const child = spawn('node', [indexPath, ...process.argv.slice(2)], {
    cwd: systemPath,
    stdio: 'inherit',
    env: {
      ...process.env,
      SEMANTIC_ANALYSIS_CWD: process.cwd(), // Pass original working directory
      SEMANTIC_ANALYSIS_SYSTEM_PATH: systemPath
    }
  });
  
  child.on('close', (code) => {
    process.exit(code);
  });
  
  child.on('error', (error) => {
    console.error('âŒ Failed to start semantic analysis:', error.message);
    process.exit(1);
  });
}

// Handle process signals
process.on('SIGINT', () => {
  console.log('\nðŸ›‘ Semantic Analysis interrupted');
  process.exit(0);
});

process.on('SIGTERM', () => {
  console.log('\nðŸ›‘ Semantic Analysis terminated');
  process.exit(0);
});

runSemanticAnalysis();