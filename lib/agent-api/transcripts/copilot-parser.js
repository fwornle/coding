/**
 * Copilot Parser - Parse GitHub Copilot CLI (copi) session logs
 *
 * Handles parsing of Copilot CLI session logs generated by copi,
 * which uses JSON-Lines format for session logging.
 *
 * Session logs are stored in:
 * - integrations/copi/logs/ (relative to coding infrastructure)
 * - Or a custom location specified by COPI_LOG_DIR
 */

import fs from 'fs/promises';
import fsSync from 'fs';
import path from 'path';
import os from 'os';
import { createLogger } from '../../logging/Logger.js';
import { LSLConverter } from './lsl-converter.js';
import { LSLEntryType } from '../transcript-api.js';

const logger = createLogger('copilot-parser');

/**
 * Copilot (Copi) Log Parser
 */
class CopilotParser {
  constructor(options = {}) {
    this.options = {
      projectPath: options.projectPath || process.cwd(),
      codingPath: options.codingPath ||
        process.env.CODING_TOOLS_PATH ||
        process.env.CODING_REPO ||
        path.join(os.homedir(), 'Agentic', 'coding'),
      logDir: options.logDir ||
        process.env.COPI_LOG_DIR ||
        null, // Will be computed in getLogDirectory
      maxSessionAge: options.maxSessionAge || 7200000, // 2 hours
      includeToolResults: options.includeToolResults !== false,
      ...options
    };

    this.converter = new LSLConverter(options);
  }

  /**
   * Get the copi log directory
   * @returns {string}
   */
  getLogDirectory() {
    if (this.options.logDir) {
      return this.options.logDir;
    }

    // Default location: integrations/copi/logs/
    return path.join(this.options.codingPath, 'integrations', 'copi', 'logs');
  }

  /**
   * List all available log files
   * @param {Object} [options]
   * @param {number} [options.limit] - Max number of files
   * @param {boolean} [options.sortNewest=true] - Sort newest first
   * @returns {Promise<Array<{path: string, mtime: Date, size: number}>>}
   */
  async listLogs(options = {}) {
    const logDir = this.getLogDirectory();

    if (!fsSync.existsSync(logDir)) {
      logger.debug(`Log directory not found: ${logDir}`);
      return [];
    }

    try {
      const files = await fs.readdir(logDir);
      const logs = [];

      for (const file of files) {
        // Copi logs are typically .jsonl or .log files
        if (!file.endsWith('.jsonl') && !file.endsWith('.log') && !file.endsWith('.json')) {
          continue;
        }

        const filePath = path.join(logDir, file);
        const stats = await fs.stat(filePath);

        // Extract session ID from filename
        // Format: session-<timestamp>.jsonl or copilot-<date>-<time>.log
        const sessionId = file.replace(/\.(jsonl|log|json)$/, '');

        logs.push({
          path: filePath,
          name: file,
          sessionId,
          mtime: stats.mtime,
          size: stats.size
        });
      }

      // Sort by modification time
      logs.sort((a, b) => {
        const order = options.sortNewest === false ? 1 : -1;
        return order * (b.mtime.getTime() - a.mtime.getTime());
      });

      // Apply limit
      if (options.limit && options.limit > 0) {
        logs.splice(options.limit);
      }

      return logs;
    } catch (error) {
      logger.error('Failed to list logs', { error: error.message });
      return [];
    }
  }

  /**
   * Find the current (most recent active) session log
   * @returns {Promise<string|null>}
   */
  async findCurrentLog() {
    const logs = await this.listLogs({ limit: 1 });

    if (logs.length === 0) {
      return null;
    }

    const mostRecent = logs[0];
    const age = Date.now() - mostRecent.mtime.getTime();

    // Only return if session is recent
    if (age > this.options.maxSessionAge) {
      logger.debug(`Most recent log too old: ${age}ms`);
      return null;
    }

    return mostRecent.path;
  }

  /**
   * Parse a single log file
   * @param {string} filePath - Path to log file
   * @returns {Promise<import('../transcript-api.js').LSLSession>}
   */
  async parseFile(filePath) {
    const content = await fs.readFile(filePath, 'utf8');
    const lines = content.trim().split('\n').filter(l => l.trim());

    const sessionId = path.basename(filePath).replace(/\.(jsonl|log|json)$/, '');
    const entries = [];
    let startTime = null;
    let endTime = null;
    let metadata = {};

    for (const line of lines) {
      try {
        const copiEntry = JSON.parse(line);

        // Check for metadata entry
        if (copiEntry.type === 'session_start' || copiEntry.type === 'metadata') {
          metadata = copiEntry;
          startTime = copiEntry.timestamp;
          continue;
        }

        if (copiEntry.type === 'session_end') {
          endTime = copiEntry.timestamp;
          continue;
        }

        const lslEntry = this.converter.fromCopiEntry(copiEntry);

        if (!lslEntry) {
          continue;
        }

        entries.push(lslEntry);

        if (!startTime && lslEntry.timestamp) {
          startTime = lslEntry.timestamp;
        }
        endTime = lslEntry.timestamp;
      } catch (error) {
        logger.debug(`Failed to parse line: ${error.message}`);
      }
    }

    return {
      metadata: {
        agent: 'copilot',
        sessionId,
        projectPath: metadata.projectPath || this.options.projectPath,
        startTime: startTime || new Date().toISOString(),
        endTime,
        userHash: metadata.userHash || process.env.USER || 'unknown',
        ...metadata
      },
      entries
    };
  }

  /**
   * Parse multiple log files
   * @param {Object} [options]
   * @param {number} [options.limit]
   * @param {Date|string} [options.since]
   * @param {Date|string} [options.until]
   * @returns {Promise<import('../transcript-api.js').LSLSession[]>}
   */
  async parseMultiple(options = {}) {
    const logs = await this.listLogs(options);
    const sessions = [];

    for (const log of logs) {
      // Filter by time range
      if (options.since) {
        const since = new Date(options.since);
        if (log.mtime < since) {
          continue;
        }
      }

      if (options.until) {
        const until = new Date(options.until);
        if (log.mtime > until) {
          continue;
        }
      }

      try {
        const session = await this.parseFile(log.path);
        sessions.push(session);
      } catch (error) {
        logger.error(`Failed to parse log: ${log.path}`, {
          error: error.message
        });
      }
    }

    return sessions;
  }

  /**
   * Stream parse a log file (for large files)
   * @param {string} filePath - Path to log file
   * @param {function(Object): void} onEntry - Callback for each entry
   * @returns {Promise<void>}
   */
  async streamParse(filePath, onEntry) {
    const readline = await import('readline');
    const fileStream = fsSync.createReadStream(filePath);

    const rl = readline.createInterface({
      input: fileStream,
      crlfDelay: Infinity
    });

    for await (const line of rl) {
      if (!line.trim()) {
        continue;
      }

      try {
        const copiEntry = JSON.parse(line);

        // Skip metadata entries
        if (copiEntry.type === 'session_start' ||
            copiEntry.type === 'session_end' ||
            copiEntry.type === 'metadata') {
          continue;
        }

        const lslEntry = this.converter.fromCopiEntry(copiEntry);

        if (lslEntry) {
          await onEntry(lslEntry);
        }
      } catch (error) {
        logger.debug(`Failed to parse streaming line: ${error.message}`);
      }
    }
  }

  /**
   * Watch a log file for new entries
   * @param {string} filePath - Path to log file
   * @param {function(Object): void} onEntry - Callback for new entries
   * @returns {Promise<{stop: function}>}
   */
  async watchFile(filePath, onEntry) {
    let lastSize = 0;
    let isWatching = true;

    // Get initial size
    try {
      const stats = await fs.stat(filePath);
      lastSize = stats.size;
    } catch {
      lastSize = 0;
    }

    const checkInterval = setInterval(async () => {
      if (!isWatching) {
        return;
      }

      try {
        const stats = await fs.stat(filePath);

        if (stats.size <= lastSize) {
          return;
        }

        // Read new content
        const fd = await fs.open(filePath, 'r');
        const buffer = Buffer.alloc(stats.size - lastSize);
        await fd.read(buffer, 0, buffer.length, lastSize);
        await fd.close();

        lastSize = stats.size;

        // Parse new lines
        const newContent = buffer.toString('utf8');
        const lines = newContent.trim().split('\n');

        for (const line of lines) {
          if (!line.trim()) {
            continue;
          }

          try {
            const copiEntry = JSON.parse(line);

            // Skip metadata entries
            if (copiEntry.type === 'session_start' ||
                copiEntry.type === 'session_end' ||
                copiEntry.type === 'metadata') {
              continue;
            }

            const lslEntry = this.converter.fromCopiEntry(copiEntry);

            if (lslEntry) {
              await onEntry(lslEntry);
            }
          } catch {
            // Skip malformed lines
          }
        }
      } catch (error) {
        logger.debug(`Watch check error: ${error.message}`);
      }
    }, 1000);

    return {
      stop: () => {
        isWatching = false;
        clearInterval(checkInterval);
      }
    };
  }
}

/**
 * Create a Copilot parser instance
 */
function createCopilotParser(options = {}) {
  return new CopilotParser(options);
}

export { CopilotParser, createCopilotParser };
export default CopilotParser;
