{
  "id": "snapshot_1762235905035_2x1gghndd",
  "approvalId": "approval_1762235905020_moxg5wir1",
  "approvalTitle": "Updated Design: 5 Teams with Heuristics and Configurations",
  "version": 1,
  "timestamp": "2025-11-04T05:58:25.035Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: Ontology Integration for Knowledge Management\n\n**Status**: Draft\n**Created**: 2025-11-03\n**Related Requirements**: `.spec-workflow/requirements/ontology-integration.md`\n\n---\n\n## 1. Executive Summary\n\nThis design document describes the architecture for integrating a configurable ontology system into the existing knowledge management infrastructure. The system will support upper (domain-level) and lower (team-specific) ontologies across multiple domains, with flexible validation and optional team-scoped classification.\n\nThe system supports five teams with distinct domain ontologies:\n- **RaaS**: Cloud orchestration for vehicle data reprocessing\n- **ReSi**: Virtual target development for embedded ADAS functions\n- **Coding**: Knowledge management infrastructure (LSL, constraints, trajectory, MCP)\n- **Agentic**: AI agent frameworks, RAG systems, and communication protocols\n- **UI**: Multi-agent curriculum alignment system with AWS serverless architecture\n\n### Key Design Principles\n\n1. **Non-Breaking Integration**: Work seamlessly with existing StreamingKnowledgeExtractor\n2. **Optional Enhancement**: Ontology classification is opt-in, doesn't affect existing functionality\n3. **Flexible Validation**: Teams can choose strict or lenient validation\n4. **Inheritance Model**: Lower ontologies extend upper ontology entities\n5. **LLM-Powered Classification**: Use UnifiedInferenceEngine with heuristic fallback\n6. **Agent-Agnostic Storage**: Store ontology metadata in existing graph database\n\n---\n\n## 2. System Architecture\n\n### 2.1 Component Overview\n\n![Ontology System Architecture](../../../docs/presentation/images/ontology-system-architecture.png)\n\n*Figure 1: Component architecture showing the integration of the Ontology System with existing Knowledge Management infrastructure*\n\n### 2.2 Component Responsibilities\n\n#### OntologyManager\n**Purpose**: Central management of ontology lifecycle and resolution\n\n**Responsibilities**:\n- Load and parse ontology files (upper and lower)\n- Resolve entity inheritance (lower extends upper)\n- Cache parsed ontologies for performance\n- Provide entity definitions to other components\n- Handle ontology reloading on file changes\n\n**Key Methods**:\n```typescript\nclass OntologyManager {\n  async loadOntology(path: string): Promise<Ontology>\n  async resolveEntity(entityClass: string, team?: string): Promise<EntityDefinition>\n  async getUpperOntology(): Promise<Ontology>\n  async getLowerOntology(team: string): Promise<Ontology>\n  async getAllEntityClasses(team?: string): Promise<string[]>\n  async reloadOntologies(): Promise<void>\n}\n```\n\n#### OntologyValidator\n**Purpose**: Validate knowledge extractions against ontology schemas\n\n**Responsibilities**:\n- Validate entity structure (required properties, types)\n- Check property value constraints\n- Validate relationships between entities\n- Support strict/lenient validation modes\n- Generate detailed validation errors\n\n**Key Methods**:\n```typescript\nclass OntologyValidator {\n  validate(\n    knowledge: Knowledge,\n    entityClass: string,\n    options: ValidationOptions\n  ): ValidationResult\n\n  validateProperty(\n    value: any,\n    propertyDef: PropertyDefinition\n  ): PropertyValidationResult\n\n  validateRelationship(\n    relationship: Relationship,\n    ontology: Ontology\n  ): ValidationResult\n}\n\ninterface ValidationOptions {\n  strict: boolean;\n  team?: string;\n  allowUnknownProperties?: boolean;\n}\n```\n\n#### OntologyClassifier\n**Purpose**: Classify knowledge extractions using LLM and ontology context\n\n**Responsibilities**:\n- Build classification prompt with ontology context\n- Call UnifiedInferenceEngine for classification\n- Apply heuristic fallback for known patterns\n- Handle mixed/flexible team scope\n- Return confidence scores\n\n**Key Methods**:\n```typescript\nclass OntologyClassifier {\n  async classify(\n    knowledge: Knowledge,\n    options: ClassificationOptions\n  ): Promise<OntologyClassification>\n\n  async classifyBatch(\n    knowledgeBatch: Knowledge[]\n  ): Promise<OntologyClassification[]>\n\n  private buildClassificationPrompt(\n    knowledge: Knowledge,\n    entityClasses: string[]\n  ): string\n\n  private applyHeuristicFallback(\n    knowledge: Knowledge\n  ): OntologyClassification | null\n}\n\ninterface ClassificationOptions {\n  team?: string; // 'ReSi' | 'RaaS' | 'mixed'\n  confidenceThreshold?: number;\n  useHeuristicFallback?: boolean;\n}\n```\n\n#### OntologyQueryEngine\n**Purpose**: Enhanced knowledge retrieval with ontology-based filtering\n\n**Responsibilities**:\n- Query knowledge by ontology entity class\n- Filter by ontology properties\n- Support inheritance-aware queries\n- Integrate with existing vector/graph search\n- Provide aggregations by entity type\n\n**Key Methods**:\n```typescript\nclass OntologyQueryEngine {\n  async findByEntityClass(\n    entityClass: string,\n    team?: string\n  ): Promise<Knowledge[]>\n\n  async findByProperty(\n    entityClass: string,\n    propertyPath: string,\n    value: any\n  ): Promise<Knowledge[]>\n\n  async aggregateByEntityClass(\n    team?: string\n  ): Promise<Map<string, number>>\n\n  async findRelated(\n    knowledgeId: string,\n    relationshipType?: string\n  ): Promise<Knowledge[]>\n}\n```\n\n---\n\n## 3. Data Model Design\n\n### 3.1 Ontology File Schema\n\n```typescript\ninterface Ontology {\n  name: string;\n  version: string;\n  type: 'upper' | 'lower';\n  team?: string; // For lower ontologies\n  extendsOntology?: string; // Path to upper ontology\n\n  entities: Record<string, EntityDefinition>;\n  relationships: Record<string, RelationshipDefinition>;\n\n  metadata: {\n    description: string;\n    domain: string;\n    createdAt: string;\n    updatedAt: string;\n  };\n}\n\ninterface EntityDefinition {\n  description: string;\n  extendsEntity?: string; // For lower ontology entities\n  properties: Record<string, PropertyDefinition>;\n  requiredProperties?: string[];\n  examples?: any[];\n}\n\ninterface PropertyDefinition {\n  type: 'string' | 'number' | 'boolean' | 'object' | 'array' | 'reference';\n  description: string;\n  required?: boolean;\n\n  // For arrays\n  items?: PropertyDefinition;\n\n  // For references\n  refersTo?: string; // Entity class name\n\n  // For enums\n  enum?: string[];\n\n  // For validation\n  pattern?: string;\n  min?: number;\n  max?: number;\n}\n\ninterface RelationshipDefinition {\n  from: string; // Entity class\n  to: string; // Entity class\n  type: string; // Relationship type\n  description: string;\n  cardinality: '1:1' | '1:N' | 'N:M';\n}\n```\n\n### 3.2 Knowledge Storage Model\n\n**Existing Knowledge Schema** (unchanged):\n```typescript\ninterface Knowledge {\n  id: string;\n  type: KnowledgeType;\n  content: string;\n  context: {\n    file?: string;\n    symbols?: string[];\n    tags?: string[];\n  };\n  timestamp: string;\n  source: string;\n\n  // NEW: Ontology metadata (optional)\n  ontology?: OntologyMetadata;\n}\n```\n\n**New Ontology Metadata**:\n```typescript\ninterface OntologyMetadata {\n  entityClass: string;\n  team?: string; // 'ReSi' | 'RaaS' | 'mixed'\n  properties: Record<string, any>;\n  relationships: OntologyRelationship[];\n\n  classification: {\n    confidence: number;\n    method: 'llm' | 'heuristic' | 'manual';\n    modelUsed?: string;\n    timestamp: string;\n  };\n\n  validation?: {\n    validated: boolean;\n    strict: boolean;\n    errors?: ValidationError[];\n  };\n}\n\ninterface OntologyRelationship {\n  type: string;\n  targetId: string;\n  targetEntityClass: string;\n  metadata?: Record<string, any>;\n}\n\ninterface ValidationError {\n  path: string;\n  message: string;\n  severity: 'error' | 'warning';\n}\n```\n\n### 3.3 File Structure\n\n```\n.data/ontologies/\n├── upper/\n│   └── cluster-reprocessing-ontology.json\n├── lower/\n│   ├── raas-ontology.json\n│   ├── resi-ontology.json\n│   ├── coding-ontology.json\n│   ├── agentic-ontology.json\n│   └── ui-ontology.json\n└── schemas/\n    ├── ontology-schema.json\n    └── validation-rules.json\n\nsrc/ontology/\n├── OntologyManager.ts\n├── OntologyValidator.ts\n├── OntologyClassifier.ts\n├── OntologyQueryEngine.ts\n├── types.ts\n└── heuristics/\n    ├── raas-heuristics.ts\n    ├── resi-heuristics.ts\n    ├── coding-heuristics.ts\n    ├── agentic-heuristics.ts\n    └── ui-heuristics.ts\n```\n\n---\n\n## 4. Integration Design\n\n### 4.1 StreamingKnowledgeExtractor Integration\n\n**Modification Points** in `src/knowledge-management/StreamingKnowledgeExtractor.js`:\n\n```typescript\nclass StreamingKnowledgeExtractor {\n  private ontologyManager?: OntologyManager;\n  private ontologyClassifier?: OntologyClassifier;\n  private ontologyValidator?: OntologyValidator;\n\n  constructor(config: KnowledgeConfig) {\n    // Existing initialization\n\n    // NEW: Initialize ontology system if configured\n    if (config.ontology?.enabled) {\n      this.ontologyManager = new OntologyManager(config.ontology);\n      this.ontologyClassifier = new OntologyClassifier(\n        this.ontologyManager,\n        this.inferenceEngine\n      );\n      if (config.ontology.validation?.enabled) {\n        this.ontologyValidator = new OntologyValidator(this.ontologyManager);\n      }\n    }\n  }\n\n  async processExchange(exchange: Exchange): Promise<void> {\n    // Existing extraction logic (unchanged)\n    const knowledge = await this.extractKnowledge(exchange);\n\n    // NEW: Classify with ontology if enabled\n    if (this.ontologyClassifier) {\n      const classification = await this.ontologyClassifier.classify(\n        knowledge,\n        {\n          team: this.config.ontology?.team,\n          confidenceThreshold: this.config.ontology?.confidenceThreshold,\n          useHeuristicFallback: true\n        }\n      );\n\n      if (classification.confidence >= (this.config.ontology?.confidenceThreshold || 0.7)) {\n        knowledge.ontology = {\n          entityClass: classification.entityClass,\n          team: classification.team,\n          properties: classification.properties,\n          relationships: [],\n          classification: {\n            confidence: classification.confidence,\n            method: classification.method,\n            modelUsed: classification.modelUsed,\n            timestamp: new Date().toISOString()\n          }\n        };\n\n        // Validate if configured\n        if (this.ontologyValidator && this.config.ontology?.validation?.enabled) {\n          const validationResult = this.ontologyValidator.validate(\n            knowledge,\n            classification.entityClass,\n            {\n              strict: this.config.ontology.validation.strict || false,\n              team: this.config.ontology.team\n            }\n          );\n\n          knowledge.ontology.validation = {\n            validated: validationResult.valid,\n            strict: this.config.ontology.validation.strict || false,\n            errors: validationResult.errors\n          };\n\n          if (!validationResult.valid && this.config.ontology.validation.strict) {\n            console.warn('Ontology validation failed (strict mode)', validationResult.errors);\n            // Still store, but with validation errors\n          }\n        }\n      }\n    }\n\n    // Existing storage logic (unchanged)\n    await this.storeKnowledge(knowledge);\n  }\n}\n```\n\n**Configuration Extension**:\n\n```typescript\ninterface KnowledgeConfig {\n  // Existing config fields...\n\n  ontology?: {\n    enabled: boolean;\n\n    // Ontology paths\n    upperOntologyPath: string;\n    lowerOntologyPath?: string;\n\n    // Team scope\n    team?: 'ReSi' | 'RaaS' | 'mixed';\n\n    // Classification\n    confidenceThreshold?: number; // Default: 0.7\n\n    // Validation\n    validation?: {\n      enabled: boolean;\n      strict: boolean; // Fail on validation errors?\n    };\n  };\n}\n```\n\n### 4.2 GraphDatabaseService Integration\n\n**Enhancement** in `src/knowledge-management/GraphDatabaseService.js`:\n\n```typescript\nclass GraphDatabaseService {\n  // Existing methods...\n\n  // NEW: Ontology-aware indexing\n  async storeKnowledge(knowledge: Knowledge): Promise<void> {\n    // Existing storage logic\n    await this.addNode(knowledge.id, {\n      type: knowledge.type,\n      content: knowledge.content,\n      // ... existing fields\n    });\n\n    // NEW: Index ontology metadata if present\n    if (knowledge.ontology) {\n      // Add ontology node attributes\n      await this.updateNodeAttributes(knowledge.id, {\n        'ontology.entityClass': knowledge.ontology.entityClass,\n        'ontology.team': knowledge.ontology.team,\n        'ontology.confidence': knowledge.ontology.classification.confidence\n      });\n\n      // Create ontology relationships\n      for (const rel of knowledge.ontology.relationships) {\n        await this.addEdge(\n          knowledge.id,\n          rel.targetId,\n          rel.type,\n          {\n            ontologyRelationship: true,\n            entityClass: knowledge.ontology.entityClass,\n            targetEntityClass: rel.targetEntityClass,\n            ...rel.metadata\n          }\n        );\n      }\n    }\n  }\n\n  // NEW: Query by ontology entity class\n  async queryByOntologyClass(\n    entityClass: string,\n    team?: string\n  ): Promise<Knowledge[]> {\n    const nodes = this.graph.nodes().filter(nodeId => {\n      const attrs = this.graph.getNodeAttributes(nodeId);\n      return attrs['ontology.entityClass'] === entityClass &&\n             (!team || attrs['ontology.team'] === team || attrs['ontology.team'] === 'mixed');\n    });\n\n    return nodes.map(nodeId => this.graph.getNodeAttributes(nodeId) as Knowledge);\n  }\n}\n```\n\n### 4.3 KnowledgeRetriever Integration\n\n**Enhancement** in `src/knowledge-management/KnowledgeRetriever.js`:\n\n```typescript\nclass KnowledgeRetriever {\n  private ontologyQueryEngine?: OntologyQueryEngine;\n\n  constructor(config: KnowledgeConfig) {\n    // Existing initialization\n\n    // NEW: Initialize ontology query engine if configured\n    if (config.ontology?.enabled) {\n      this.ontologyQueryEngine = new OntologyQueryEngine(\n        this.graphDb,\n        this.vectorDb\n      );\n    }\n  }\n\n  // NEW: Ontology-based retrieval\n  async retrieveByOntology(query: OntologyQuery): Promise<Knowledge[]> {\n    if (!this.ontologyQueryEngine) {\n      throw new Error('Ontology system not enabled');\n    }\n\n    return this.ontologyQueryEngine.findByEntityClass(\n      query.entityClass,\n      query.team\n    );\n  }\n\n  // ENHANCED: Hybrid retrieval (semantic + ontology)\n  async retrieve(query: RetrievalQuery): Promise<Knowledge[]> {\n    // Existing semantic search\n    let results = await this.semanticSearch(query.text, query.limit);\n\n    // NEW: Filter by ontology if specified\n    if (query.ontology && this.ontologyQueryEngine) {\n      const ontologyResults = await this.ontologyQueryEngine.findByEntityClass(\n        query.ontology.entityClass,\n        query.ontology.team\n      );\n\n      // Intersect results\n      const ontologyIds = new Set(ontologyResults.map(k => k.id));\n      results = results.filter(k => ontologyIds.has(k.id));\n    }\n\n    return results;\n  }\n}\n\ninterface RetrievalQuery {\n  text: string;\n  limit?: number;\n  ontology?: {\n    entityClass: string;\n    team?: string;\n  };\n}\n```\n\n---\n\n## 5. API Design\n\n### 5.1 OntologyManager API\n\n```typescript\nclass OntologyManager {\n  /**\n   * Load ontology from file path\n   * @param path - Absolute or relative path to ontology JSON file\n   * @returns Parsed ontology object\n   */\n  async loadOntology(path: string): Promise<Ontology>;\n\n  /**\n   * Resolve entity definition with inheritance\n   * @param entityClass - Entity class name\n   * @param team - Optional team scope for lower ontology\n   * @returns Merged entity definition (lower extends upper)\n   */\n  async resolveEntity(\n    entityClass: string,\n    team?: string\n  ): Promise<EntityDefinition>;\n\n  /**\n   * Get all entity classes for a team\n   * @param team - Team scope (includes upper + lower if team specified)\n   * @returns Array of entity class names\n   */\n  async getAllEntityClasses(team?: string): Promise<string[]>;\n\n  /**\n   * Get relationship definitions\n   * @param team - Optional team scope\n   * @returns Map of relationship name to definition\n   */\n  async getRelationships(\n    team?: string\n  ): Promise<Record<string, RelationshipDefinition>>;\n\n  /**\n   * Reload ontologies from disk (for hot-reloading)\n   */\n  async reloadOntologies(): Promise<void>;\n\n  /**\n   * Validate ontology file structure\n   * @param path - Path to ontology file\n   * @returns Validation result with errors if any\n   */\n  async validateOntologyFile(path: string): Promise<ValidationResult>;\n}\n```\n\n### 5.2 OntologyClassifier API\n\n```typescript\nclass OntologyClassifier {\n  /**\n   * Classify single knowledge extraction\n   * @param knowledge - Knowledge object to classify\n   * @param options - Classification options\n   * @returns Classification result with confidence score\n   */\n  async classify(\n    knowledge: Knowledge,\n    options: ClassificationOptions\n  ): Promise<OntologyClassification>;\n\n  /**\n   * Classify batch of knowledge extractions (efficient)\n   * @param knowledgeBatch - Array of knowledge objects\n   * @param options - Classification options\n   * @returns Array of classification results\n   */\n  async classifyBatch(\n    knowledgeBatch: Knowledge[],\n    options: ClassificationOptions\n  ): Promise<OntologyClassification[]>;\n\n  /**\n   * Get classification prompt (for debugging)\n   * @param knowledge - Knowledge object\n   * @param entityClasses - Available entity classes\n   * @returns Generated prompt string\n   */\n  getClassificationPrompt(\n    knowledge: Knowledge,\n    entityClasses: string[]\n  ): string;\n}\n\ninterface OntologyClassification {\n  entityClass: string;\n  team?: string;\n  confidence: number; // 0.0 to 1.0\n  method: 'llm' | 'heuristic' | 'manual';\n  modelUsed?: string;\n  properties: Record<string, any>;\n  reasoning?: string; // LLM explanation\n}\n```\n\n### 5.3 OntologyQueryEngine API\n\n```typescript\nclass OntologyQueryEngine {\n  /**\n   * Find knowledge by entity class\n   * @param entityClass - Entity class name\n   * @param team - Optional team filter\n   * @param options - Query options\n   * @returns Matching knowledge objects\n   */\n  async findByEntityClass(\n    entityClass: string,\n    team?: string,\n    options?: QueryOptions\n  ): Promise<Knowledge[]>;\n\n  /**\n   * Find knowledge by property value\n   * @param entityClass - Entity class name\n   * @param propertyPath - Dot-separated property path\n   * @param value - Property value to match\n   * @returns Matching knowledge objects\n   */\n  async findByProperty(\n    entityClass: string,\n    propertyPath: string,\n    value: any\n  ): Promise<Knowledge[]>;\n\n  /**\n   * Aggregate counts by entity class\n   * @param team - Optional team filter\n   * @returns Map of entity class to count\n   */\n  async aggregateByEntityClass(\n    team?: string\n  ): Promise<Map<string, number>>;\n\n  /**\n   * Find related knowledge via ontology relationships\n   * @param knowledgeId - Starting knowledge ID\n   * @param relationshipType - Optional relationship type filter\n   * @returns Related knowledge objects\n   */\n  async findRelated(\n    knowledgeId: string,\n    relationshipType?: string\n  ): Promise<Knowledge[]>;\n\n  /**\n   * Query with complex filters\n   * @param query - Complex query object\n   * @returns Matching knowledge objects\n   */\n  async query(query: OntologyQuery): Promise<Knowledge[]>;\n}\n\ninterface QueryOptions {\n  limit?: number;\n  offset?: number;\n  sortBy?: string;\n  includeValidationErrors?: boolean;\n}\n\ninterface OntologyQuery {\n  entityClass?: string;\n  team?: string;\n  properties?: Record<string, any>;\n  relationships?: RelationshipFilter[];\n  confidenceThreshold?: number;\n}\n```\n\n---\n\n## 6. Sequence Diagrams\n\n### 6.1 Knowledge Extraction with Ontology\n\n![Knowledge Extraction with Ontology](../../../docs/presentation/images/knowledge-extraction-ontology.png)\n\n*Figure 2: Sequence diagram showing how ontology classification and validation are integrated into the knowledge extraction workflow*\n\n### 6.2 Ontology-Based Query\n\n![Ontology-Based Query](../../../docs/presentation/images/ontology-query.png)\n\n*Figure 3: Sequence diagram showing how ontology-based queries retrieve knowledge by entity class and properties*\n\n### 6.3 Ontology Resolution (Upper + Lower)\n\n![Ontology Resolution](../../../docs/presentation/images/ontology-resolution.png)\n\n*Figure 4: Sequence diagram showing how entity definitions are resolved by merging upper and lower ontologies with caching*\n\n---\n\n## 7. Implementation Considerations\n\n### 7.1 Performance Optimization\n\n1. **Ontology Caching**:\n   - Cache parsed ontology files in memory\n   - Invalidate cache on file change (watch for modifications)\n   - Use LRU cache for resolved entity definitions\n\n2. **Batch Classification**:\n   - Process multiple knowledge extractions in single LLM call\n   - Use streaming inference for real-time classification\n   - Batch validation checks\n\n3. **Index Optimization**:\n   - Create graph indices on `ontology.entityClass` and `ontology.team`\n   - Use Qdrant payload indexing for ontology metadata\n   - Cache frequent queries\n\n4. **Lazy Loading**:\n   - Load lower ontologies only when team scope is specified\n   - Defer validation until explicitly requested\n   - Load ontology relationships on-demand\n\n### 7.2 Error Handling\n\n1. **Ontology File Errors**:\n```typescript\nclass OntologyError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public path?: string\n  ) {\n    super(message);\n    this.name = 'OntologyError';\n  }\n}\n\n// Error codes:\n// - ONTOLOGY_NOT_FOUND\n// - ONTOLOGY_PARSE_ERROR\n// - ONTOLOGY_VALIDATION_ERROR\n// - ENTITY_NOT_FOUND\n// - PROPERTY_VALIDATION_ERROR\n```\n\n2. **Classification Errors**:\n   - Fallback to heuristics if LLM fails\n   - Log classification failures for analysis\n   - Continue processing even if classification fails (ontology is optional)\n\n3. **Validation Errors**:\n   - Store validation errors with knowledge object\n   - Don't block storage in lenient mode\n   - Provide detailed error messages with property paths\n\n### 7.3 Configuration Management\n\n**Default Configuration** (`config/knowledge-management.json`):\n\n```json\n{\n  \"ontology\": {\n    \"enabled\": true,\n    \"upperOntologyPath\": \".data/ontologies/upper/cluster-reprocessing-ontology.json\",\n    \"team\": \"mixed\",\n    \"confidenceThreshold\": 0.7,\n    \"validation\": {\n      \"enabled\": true,\n      \"strict\": false\n    },\n    \"caching\": {\n      \"enabled\": true,\n      \"ttl\": 3600000,\n      \"maxSize\": 100\n    },\n    \"classification\": {\n      \"batchSize\": 10,\n      \"useHeuristicFallback\": true,\n      \"heuristicThreshold\": 0.8\n    }\n  }\n}\n```\n\n**Team-Specific Configuration** (`config/teams/`):\n\n```json\n// config/teams/raas.json\n{\n  \"team\": \"RaaS\",\n  \"lowerOntologyPath\": \".data/ontologies/lower/raas-ontology.json\",\n  \"validation\": {\n    \"strict\": true\n  }\n}\n\n// config/teams/resi.json\n{\n  \"team\": \"ReSi\",\n  \"lowerOntologyPath\": \".data/ontologies/lower/resi-ontology.json\",\n  \"validation\": {\n    \"strict\": false\n  }\n}\n\n// config/teams/coding.json\n{\n  \"team\": \"coding\",\n  \"lowerOntologyPath\": \".data/ontologies/lower/coding-ontology.json\",\n  \"validation\": {\n    \"strict\": true\n  }\n}\n\n// config/teams/agentic.json\n{\n  \"team\": \"agentic\",\n  \"lowerOntologyPath\": \".data/ontologies/lower/agentic-ontology.json\",\n  \"validation\": {\n    \"strict\": false\n  }\n}\n\n// config/teams/ui.json\n{\n  \"team\": \"ui\",\n  \"lowerOntologyPath\": \".data/ontologies/lower/ui-ontology.json\",\n  \"validation\": {\n    \"strict\": true\n  }\n}\n```\n\n### 7.4 Testing Strategy\n\n1. **Unit Tests**:\n   - OntologyManager: Loading, parsing, resolution\n   - OntologyValidator: Property validation, schema validation\n   - OntologyClassifier: Prompt building, heuristics\n   - OntologyQueryEngine: Query filtering, aggregations\n\n2. **Integration Tests**:\n   - StreamingKnowledgeExtractor with ontology system\n   - End-to-end classification and storage\n   - Query retrieval with ontology filters\n   - Upper + lower ontology inheritance\n\n3. **Performance Tests**:\n   - Classification throughput (extractions/second)\n   - Query performance with large knowledge base\n   - Memory usage with cached ontologies\n\n4. **Test Fixtures**:\n```typescript\n// tests/fixtures/ontologies/test-upper-ontology.json\n{\n  \"name\": \"test-upper\",\n  \"version\": \"1.0.0\",\n  \"type\": \"upper\",\n  \"entities\": {\n    \"TestEntity\": {\n      \"description\": \"Test entity\",\n      \"properties\": {\n        \"id\": { \"type\": \"string\", \"required\": true },\n        \"value\": { \"type\": \"number\" }\n      }\n    }\n  },\n  \"relationships\": {},\n  \"metadata\": {\n    \"description\": \"Test ontology\",\n    \"domain\": \"test\"\n  }\n}\n```\n\n### 7.5 Migration Strategy\n\n**Phase 1: Non-Breaking Addition** (Week 1)\n- Add ontology system alongside existing system\n- No changes to existing knowledge extraction\n- Enable via configuration flag\n\n**Phase 2: Gradual Enablement** (Week 2-3)\n- Enable ontology classification for new knowledge\n- Backfill ontology metadata for recent knowledge (optional)\n- Monitor classification accuracy and performance\n\n**Phase 3: Full Integration** (Week 4-5)\n- Integrate ontology queries into retrieval workflows\n- Update dashboards to show ontology metrics\n- Document best practices for ontology usage\n\n**Rollback Plan**:\n- Disable ontology system via configuration\n- Existing knowledge without ontology metadata remains functional\n- No data migration required for rollback\n\n---\n\n## 8. Security and Privacy\n\n### 8.1 Data Sensitivity\n\n- Ontology files may contain proprietary domain knowledge\n- Knowledge extractions may include sensitive code patterns\n- LLM classification prompts should not include PII or secrets\n\n### 8.2 Access Control\n\n- Ontology files stored in `.data/` (git-ignored)\n- Team-specific ontologies require authentication\n- Query API should enforce team-based access control (future enhancement)\n\n### 8.3 Audit Trail\n\n```typescript\ninterface OntologyAuditLog {\n  timestamp: string;\n  action: 'classify' | 'validate' | 'query';\n  entityClass: string;\n  team?: string;\n  user?: string;\n  result: 'success' | 'failure';\n  metadata?: Record<string, any>;\n}\n```\n\n---\n\n## 9. Monitoring and Observability\n\n### 9.1 Metrics\n\n```typescript\ninterface OntologyMetrics {\n  // Classification metrics\n  classificationsPerSecond: number;\n  classificationLatency: Histogram;\n  classificationConfidence: Histogram;\n  heuristicFallbackRate: number;\n\n  // Validation metrics\n  validationsPerSecond: number;\n  validationFailureRate: number;\n  strictValidationFailureRate: number;\n\n  // Query metrics\n  queriesByEntityClass: Map<string, number>;\n  queryLatency: Histogram;\n\n  // Cache metrics\n  cacheHitRate: number;\n  cacheSize: number;\n}\n```\n\n### 9.2 Logging\n\n```typescript\nlogger.info('Ontology classification', {\n  knowledgeId: knowledge.id,\n  entityClass: classification.entityClass,\n  confidence: classification.confidence,\n  method: classification.method,\n  team: classification.team,\n  latency: classificationTime\n});\n\nlogger.warn('Ontology validation failed', {\n  knowledgeId: knowledge.id,\n  entityClass: knowledge.ontology.entityClass,\n  errors: validationResult.errors,\n  strict: options.strict\n});\n```\n\n---\n\n## 10. Future Enhancements\n\n### 10.1 Short-Term (3-6 months)\n\n1. **Relationship Extraction**: Automatically detect and store ontology relationships between knowledge extractions\n2. **Ontology Versioning**: Support multiple ontology versions and migration paths\n3. **Visual Ontology Editor**: Web-based UI for creating and editing ontologies\n4. **Advanced Heuristics**: Machine learning-based heuristic classification\n\n### 10.2 Long-Term (6-12 months)\n\n1. **Cross-Project Ontologies**: Share ontologies across multiple projects\n2. **Ontology Alignment**: Automatically map between different ontologies\n3. **Temporal Ontologies**: Track how entity definitions evolve over time\n4. **Federated Ontologies**: Integrate with external ontology standards (OWL, SKOS)\n\n---\n\n## 11. Acceptance Criteria\n\n### 11.1 Functional Requirements\n\n- [ ] OntologyManager loads and parses upper and lower ontologies\n- [ ] OntologyClassifier classifies knowledge using LLM and heuristics\n- [ ] OntologyValidator validates knowledge against entity schemas\n- [ ] OntologyQueryEngine retrieves knowledge by entity class\n- [ ] StreamingKnowledgeExtractor integrates ontology classification seamlessly\n- [ ] System works with mixed team scope\n- [ ] Validation supports strict and lenient modes\n- [ ] Configuration is flexible and team-specific\n\n### 11.2 Non-Functional Requirements\n\n- [ ] Classification latency < 500ms (p95)\n- [ ] Query latency < 100ms (p95)\n- [ ] No performance degradation when ontology disabled\n- [ ] Memory usage increase < 50MB with cached ontologies\n- [ ] Classification accuracy > 85% (LLM) or > 90% (heuristic)\n- [ ] System handles 100+ entity classes efficiently\n\n### 11.3 Integration Requirements\n\n- [ ] No breaking changes to existing knowledge management API\n- [ ] Backward compatible with knowledge without ontology metadata\n- [ ] Works with existing graph and vector databases\n- [ ] Integrates with existing LLM inference engine\n\n---\n\n## 12. Open Questions\n\n1. **Ontology Evolution**: How should we handle ontology schema changes over time? Should we version ontologies explicitly?\n\n2. **Multi-Ontology Knowledge**: Can a single knowledge extraction belong to multiple entity classes? (Current design: single entity class)\n\n3. **Relationship Inference**: Should relationships be manually defined or automatically inferred from co-occurrence patterns?\n\n4. **External Ontologies**: Should we support importing standard ontologies (e.g., Dublin Core, FOAF)?\n\n5. **Query Language**: Should we develop a custom query DSL for complex ontology queries, or use existing query languages?\n\n---\n\n## Appendix A: Entity Class Examples\n\n### Upper Ontology Examples\n\n```json\n{\n  \"RecordedData\": {\n    \"description\": \"Vehicle sensor and ECU data captured during test drives\",\n    \"properties\": {\n      \"sources\": {\n        \"type\": \"array\",\n        \"items\": { \"type\": \"string\", \"enum\": [\"camera\", \"radar\", \"lidar\", \"SOME/IP\", \"MIPI\"] },\n        \"description\": \"Data source types\"\n      },\n      \"containerFormat\": {\n        \"type\": \"string\",\n        \"enum\": [\"MF4\", \"MCAP\"],\n        \"description\": \"File container format\"\n      },\n      \"payloadFormat\": {\n        \"type\": \"string\",\n        \"enum\": [\"Protobuf/SPP\", \"Kaitai-Binary\", \"raw\"],\n        \"description\": \"Payload encoding format\"\n      },\n      \"metadata\": {\n        \"type\": \"object\",\n        \"description\": \"Recording metadata (vehicle, timestamp, location, etc.)\"\n      }\n    },\n    \"requiredProperties\": [\"sources\", \"containerFormat\"]\n  },\n\n  \"RPU\": {\n    \"description\": \"Reprocessing Unit - containerized virtual target execution environment\",\n    \"properties\": {\n      \"imageId\": { \"type\": \"string\", \"description\": \"Docker image identifier\" },\n      \"imageTag\": { \"type\": \"string\", \"description\": \"Image version tag\" },\n      \"artifactoryPath\": { \"type\": \"string\", \"description\": \"Path in Artifactory\" },\n      \"virtualTarget\": {\n        \"type\": \"reference\",\n        \"refersTo\": \"VirtualTarget\",\n        \"description\": \"Virtual target executed in this RPU\"\n      },\n      \"resourceRequirements\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"cpu\": { \"type\": \"string\" },\n          \"memory\": { \"type\": \"string\" }\n        }\n      }\n    },\n    \"requiredProperties\": [\"imageId\", \"virtualTarget\"]\n  }\n}\n```\n\n### Lower Ontology Examples (RaaS)\n\n```json\n{\n  \"ArgoWorkflowTemplate\": {\n    \"description\": \"Argo Workflow template for orchestrating compound reprocessing\",\n    \"extendsEntity\": \"CompoundReprocessing\",\n    \"properties\": {\n      \"templateName\": { \"type\": \"string\", \"required\": true },\n      \"namespace\": { \"type\": \"string\", \"required\": true },\n      \"dagSpec\": {\n        \"type\": \"object\",\n        \"description\": \"Argo DAG specification\"\n      },\n      \"rpuSteps\": {\n        \"type\": \"array\",\n        \"items\": { \"type\": \"reference\", \"refersTo\": \"RPU\" },\n        \"description\": \"RPU components in workflow\"\n      },\n      \"parallelization\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"maxConcurrency\": { \"type\": \"number\" },\n          \"strategy\": { \"type\": \"string\", \"enum\": [\"fan-out\", \"sequential\", \"adaptive\"] }\n        }\n      }\n    }\n  },\n\n  \"RDQFramework\": {\n    \"description\": \"RaaS Data Quality framework for validation\",\n    \"properties\": {\n      \"rules\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"ruleId\": { \"type\": \"string\" },\n            \"condition\": { \"type\": \"string\" },\n            \"severity\": { \"type\": \"string\", \"enum\": [\"error\", \"warning\", \"info\"] }\n          }\n        }\n      },\n      \"reportingEndpoint\": { \"type\": \"string\" },\n      \"alertThresholds\": { \"type\": \"object\" }\n    }\n  }\n}\n```\n\n---\n\n## Revision History\n\n| Version | Date | Author | Changes |\n|---------|------|--------|---------|\n| 1.0 | 2025-11-03 | Claude | Initial design document |\n\n",
  "fileStats": {
    "size": 32774,
    "lines": 1224,
    "lastModified": "2025-11-04T05:54:27.304Z"
  },
  "comments": []
}