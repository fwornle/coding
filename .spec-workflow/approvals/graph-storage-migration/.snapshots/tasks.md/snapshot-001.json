{
  "id": "snapshot_1761038977770_iv3tfgw7p",
  "approvalId": "approval_1761038977765_ltr26y708",
  "approvalTitle": "Graph Storage Migration - Tasks Document",
  "version": 1,
  "timestamp": "2025-10-21T09:29:37.770Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document\n\n## Overview\n\nThis document breaks down the implementation of the graph storage migration into actionable development tasks. Tasks are organized by component and include acceptance criteria, dependencies, and time estimates.\n\n**Total Estimated Time**: 12-16 hours\n**Implementation Order**: Sequential by phase (dependencies enforced)\n\n---\n\n## Phase 1: Foundation & Setup (2-3 hours)\n\n### Task 1.1: Install and Verify Dependencies\n\n**Status**: [ ] Pending\n**Priority**: Critical (Blocks all other tasks)\n**Estimated Time**: 30 minutes\n\n**Description**: Install Level v10.0.0 and verify compatibility with Node.js 24.\n\n**Acceptance Criteria**:\n- [ ] `level` package installed via npm (v10.0.0)\n- [ ] Test script verifies Level works with Node.js 24.5.0\n- [ ] Level database can be created, written to, and read from\n- [ ] LevelGraph confirmed as NOT used (documented as incompatible)\n\n**Implementation Steps**:\n```bash\n# Install Level\nnpm install level@10.0.0\n\n# Create test script: scripts/test-level-db.js\n# Verify basic operations: open, put, get, close\nnode scripts/test-level-db.js\n```\n\n**Files Modified**:\n- `package.json` (add `level@10.0.0` to dependencies)\n- `scripts/test-level-db.js` (new test script)\n\n**Verification**:\n```bash\nnode scripts/test-level-db.js\n# Expected: âœ“ Level DB test passed\n```\n\n---\n\n### Task 1.2: Create Graph Database Configuration\n\n**Status**: [ ] Pending\n**Priority**: High\n**Estimated Time**: 30 minutes\n**Depends On**: None\n\n**Description**: Create configuration file for graph database settings.\n\n**Acceptance Criteria**:\n- [ ] Configuration file created at `config/graph-database-config.json`\n- [ ] Environment variables defined for runtime overrides\n- [ ] Configuration includes database path, persistence settings, performance tuning\n- [ ] Configuration follows project's existing config patterns\n\n**Implementation Steps**:\n```javascript\n// config/graph-database-config.json\n{\n  \"database\": {\n    \"type\": \"graphology-level\",\n    \"path\": \".data/knowledge-graph\",\n    \"options\": {\n      \"multi\": true,\n      \"valueEncoding\": \"json\"\n    }\n  },\n  \"persistence\": {\n    \"autoPersist\": true,\n    \"persistIntervalMs\": 1000,\n    \"batchSize\": 100\n  },\n  \"performance\": {\n    \"maxTraversalDepth\": 5,\n    \"maxResultsPerQuery\": 1000\n  },\n  \"query\": {\n    \"defaultLimit\": 1000,\n    \"maxLimit\": 10000,\n    \"enableCaching\": true,\n    \"cacheExpiryMs\": 60000\n  }\n}\n```\n\n**Files Created**:\n- `config/graph-database-config.json`\n\n**Environment Variables**:\n```bash\nGRAPH_DB_PATH=.data/knowledge-graph\nCODING_TEAM=coding\nGRAPH_MAX_TRAVERSAL_DEPTH=5\nGRAPH_MAX_RESULTS=1000\nGRAPH_ENABLE_CACHE=true\nGRAPH_CACHE_EXPIRY_MS=60000\n```\n\n---\n\n### Task 1.3: Create GraphDatabaseService Skeleton\n\n**Status**: [ ] Pending\n**Priority**: High\n**Estimated Time**: 1 hour\n**Depends On**: Task 1.1, Task 1.2\n\n**Description**: Create the GraphDatabaseService class with all method signatures and basic structure.\n\n**Acceptance Criteria**:\n- [ ] Class created at `src/knowledge-management/GraphDatabaseService.js`\n- [ ] All public methods defined with JSDoc comments\n- [ ] EventEmitter inheritance for lifecycle events\n- [ ] Configuration loading from config file\n- [ ] Health check method stubbed\n\n**Implementation Steps**:\n```javascript\n// src/knowledge-management/GraphDatabaseService.js\nimport { EventEmitter } from 'events';\nimport Graph from 'graphology';\nimport { Level } from 'level';\nimport fs from 'fs/promises';\n\nexport class GraphDatabaseService extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.config = options.config || {};\n    this.dbPath = options.dbPath || '.data/knowledge-graph';\n    this.graph = null;\n    this.levelDB = null;\n    this.inMemoryOnly = false;\n  }\n\n  async initialize() { /* TODO */ }\n  async storeEntity(entity, options = {}) { /* TODO */ }\n  async getEntity(name, team) { /* TODO */ }\n  async storeRelationship(from, to, type, metadata = {}) { /* TODO */ }\n  async findRelated(entityName, depth = 2, filter = {}) { /* TODO */ }\n  async queryEntities(options = {}) { /* TODO */ }\n  async queryRelations(options = {}) { /* TODO */ }\n  async getTeams() { /* TODO */ }\n  async getStatistics(options = {}) { /* TODO */ }\n  async exportToJSON(team, filePath) { /* TODO */ }\n  async importFromJSON(filePath) { /* TODO */ }\n  async getHealth() { /* TODO */ }\n  async close() { /* TODO */ }\n}\n```\n\n**Files Created**:\n- `src/knowledge-management/GraphDatabaseService.js`\n\n**Verification**:\n```bash\nnode -e \"import('./src/knowledge-management/GraphDatabaseService.js').then(m => console.log('âœ“ Import successful'))\"\n```\n\n---\n\n## Phase 2: GraphDatabaseService Implementation (4-5 hours)\n\n### Task 2.1: Implement Core Graph Operations\n\n**Status**: [ ] Pending\n**Priority**: Critical\n**Estimated Time**: 2 hours\n**Depends On**: Task 1.3\n\n**Description**: Implement initialize(), storeEntity(), getEntity(), storeRelationship() methods.\n\n**Acceptance Criteria**:\n- [ ] `initialize()` creates Graphology graph and opens Level DB\n- [ ] `storeEntity()` creates/updates graph nodes with team-based IDs (`{team}:{name}`)\n- [ ] `getEntity()` retrieves entity attributes from graph\n- [ ] `storeRelationship()` creates graph edges with metadata\n- [ ] All operations persist to Level DB\n- [ ] Events emitted for entity:stored and relationship:stored\n\n**Implementation Steps**:\n1. Implement `initialize()`:\n   - Create `new Graph({ multi: true })` (Graphology)\n   - Open Level DB at configured path\n   - Load existing graph from Level if exists\n   - Emit 'ready' event\n\n2. Implement `storeEntity()`:\n   - Generate node ID: `${team}:${entityName}`\n   - Add/update node with attributes\n   - Persist to Level DB\n   - Emit 'entity:stored' event\n\n3. Implement `getEntity()`:\n   - Construct node ID from name + team\n   - Retrieve node attributes from graph\n   - Return entity or null\n\n4. Implement `storeRelationship()`:\n   - Validate both entities exist\n   - Add edge with type and metadata\n   - Persist to Level DB\n   - Emit 'relationship:stored' event\n\n**Files Modified**:\n- `src/knowledge-management/GraphDatabaseService.js`\n\n**Test Coverage**:\n```javascript\n// tests/unit/GraphDatabaseService.test.js\ndescribe('GraphDatabaseService', () => {\n  test('storeEntity creates node with correct ID', async () => {\n    const entity = { name: 'JWT', entityType: 'Pattern' };\n    const nodeId = await graphDB.storeEntity(entity, { team: 'coding' });\n    expect(nodeId).toBe('coding:JWT');\n  });\n\n  test('storeRelationship creates edge', async () => {\n    await graphDB.storeEntity({ name: 'A' }, { team: 'test' });\n    await graphDB.storeEntity({ name: 'B' }, { team: 'test' });\n    await graphDB.storeRelationship('A', 'B', 'implements', { team: 'test' });\n    expect(graphDB.graph.hasEdge('test:A', 'test:B')).toBe(true);\n  });\n});\n```\n\n---\n\n### Task 2.2: Implement Graph Traversal (findRelated)\n\n**Status**: [ ] Pending\n**Priority**: High\n**Estimated Time**: 1.5 hours\n**Depends On**: Task 2.1\n\n**Description**: Implement graph traversal with depth control and filtering.\n\n**Acceptance Criteria**:\n- [ ] `findRelated()` traverses graph up to specified depth\n- [ ] Returns array of related entities with depth and relationship type\n- [ ] Filters by team, relationship type, entity type\n- [ ] Uses BFS (breadth-first search) for consistent ordering\n- [ ] Prevents infinite loops (visited set)\n- [ ] Performance: <50ms for 2-hop traversal with 1000 entities\n\n**Implementation Steps**:\n```javascript\nasync findRelated(entityName, depth = 2, filter = {}) {\n  const team = filter.team || 'default';\n  const nodeId = `${team}:${entityName}`;\n\n  if (!this.graph.hasNode(nodeId)) return [];\n\n  const results = [];\n  const visited = new Set([nodeId]);\n  const queue = [{ nodeId, currentDepth: 0 }];\n\n  while (queue.length > 0) {\n    const { nodeId: current, currentDepth } = queue.shift();\n\n    if (currentDepth >= depth) continue;\n\n    // Get neighbors (both in and out edges)\n    const neighbors = this.graph.neighbors(current);\n\n    for (const neighbor of neighbors) {\n      if (visited.has(neighbor)) continue;\n      visited.add(neighbor);\n\n      const entity = this.graph.getNodeAttributes(neighbor);\n\n      // Apply filters\n      if (filter.entityType && entity.entityType !== filter.entityType) continue;\n\n      results.push({\n        entity,\n        depth: currentDepth + 1,\n        path: this._getPathType(current, neighbor)\n      });\n\n      queue.push({ nodeId: neighbor, currentDepth: currentDepth + 1 });\n    }\n  }\n\n  return results;\n}\n```\n\n**Test Coverage**:\n```javascript\ntest('findRelated traverses 2 hops correctly', async () => {\n  // A -> B -> C\n  await graphDB.storeEntity({ name: 'A' }, { team: 'test' });\n  await graphDB.storeEntity({ name: 'B' }, { team: 'test' });\n  await graphDB.storeEntity({ name: 'C' }, { team: 'test' });\n  await graphDB.storeRelationship('A', 'B', 'implements', { team: 'test' });\n  await graphDB.storeRelationship('B', 'C', 'uses', { team: 'test' });\n\n  const related = await graphDB.findRelated('A', 2, { team: 'test' });\n\n  expect(related).toHaveLength(2);\n  expect(related.some(r => r.entity.name === 'B' && r.depth === 1)).toBe(true);\n  expect(related.some(r => r.entity.name === 'C' && r.depth === 2)).toBe(true);\n});\n```\n\n---\n\n### Task 2.3: Implement SQL-Compatible Query Interface\n\n**Status**: [ ] Pending\n**Priority**: Critical (Required for VKB/UKB integration)\n**Estimated Time**: 2 hours\n**Depends On**: Task 2.1\n\n**Description**: Implement queryEntities(), queryRelations(), getTeams(), getStatistics() with SQL-compatible filtering.\n\n**Acceptance Criteria**:\n- [ ] `queryEntities()` supports all filter options (team, source, types, dates, confidence, search, pagination)\n- [ ] `queryRelations()` filters by entity, team, relationship type\n- [ ] `getTeams()` returns unique list of teams\n- [ ] `getStatistics()` returns entity/relationship counts by team/type\n- [ ] Query results match SQLite query result format exactly\n- [ ] Pagination works correctly (limit, offset)\n\n**Implementation Steps**:\n```javascript\nasync queryEntities(options = {}) {\n  const {\n    team = null,\n    source = null,\n    types = null,\n    startDate = null,\n    endDate = null,\n    minConfidence = 0,\n    limit = 1000,\n    offset = 0,\n    searchTerm = null,\n    sortBy = 'last_modified',\n    sortOrder = 'DESC'\n  } = options;\n\n  let entities = [];\n\n  // Iterate all nodes\n  this.graph.forEachNode((nodeId, attributes) => {\n    // Apply filters\n    if (team && attributes.team !== team) return;\n    if (source && attributes.source !== source) return;\n    if (types && !types.includes(attributes.entityType)) return;\n    if (attributes.confidence < minConfidence) return;\n    if (searchTerm && !this._matchesSearch(attributes, searchTerm)) return;\n\n    // Date filtering\n    const lastModified = new Date(attributes.last_modified);\n    if (startDate && lastModified < new Date(startDate)) return;\n    if (endDate && lastModified > new Date(endDate)) return;\n\n    entities.push({\n      id: nodeId,\n      ...attributes\n    });\n  });\n\n  // Sort\n  entities.sort((a, b) => {\n    const aVal = a[sortBy];\n    const bVal = b[sortBy];\n    return sortOrder === 'DESC' ? (bVal > aVal ? 1 : -1) : (aVal > bVal ? 1 : -1);\n  });\n\n  // Paginate\n  return entities.slice(offset, offset + limit);\n}\n\nasync queryRelations(options = {}) {\n  const { entityId = null, team = null, relationType = null, limit = 1000 } = options;\n\n  const relations = [];\n\n  this.graph.forEachEdge((edge, attributes, source, target) => {\n    // Apply filters\n    if (entityId && source !== entityId && target !== entityId) return;\n    if (team) {\n      const sourceTeam = this.graph.getNodeAttribute(source, 'team');\n      if (sourceTeam !== team) return;\n    }\n    if (relationType && attributes.type !== relationType) return;\n\n    relations.push({\n      from: source,\n      to: target,\n      type: attributes.type,\n      ...attributes\n    });\n  });\n\n  return relations.slice(0, limit);\n}\n\nasync getTeams() {\n  const teams = new Set();\n  this.graph.forEachNode((nodeId, attributes) => {\n    if (attributes.team) teams.add(attributes.team);\n  });\n  return Array.from(teams).sort();\n}\n\nasync getStatistics(options = {}) {\n  const { team = null } = options;\n\n  let entityCount = 0;\n  let relationCount = 0;\n  const typeDistribution = {};\n\n  this.graph.forEachNode((nodeId, attributes) => {\n    if (team && attributes.team !== team) return;\n    entityCount++;\n    const type = attributes.entityType || 'Unknown';\n    typeDistribution[type] = (typeDistribution[type] || 0) + 1;\n  });\n\n  this.graph.forEachEdge((edge, attributes, source) => {\n    if (team) {\n      const sourceTeam = this.graph.getNodeAttribute(source, 'team');\n      if (sourceTeam !== team) return;\n    }\n    relationCount++;\n  });\n\n  return {\n    entityCount,\n    relationCount,\n    typeDistribution,\n    teams: await this.getTeams()\n  };\n}\n```\n\n**Test Coverage**:\n```javascript\ntest('queryEntities filters by team', async () => {\n  await graphDB.storeEntity({ name: 'A' }, { team: 'team1' });\n  await graphDB.storeEntity({ name: 'B' }, { team: 'team2' });\n\n  const results = await graphDB.queryEntities({ team: 'team1' });\n\n  expect(results).toHaveLength(1);\n  expect(results[0].name).toBe('A');\n});\n\ntest('queryRelations filters by type', async () => {\n  await graphDB.storeEntity({ name: 'A' }, { team: 'test' });\n  await graphDB.storeEntity({ name: 'B' }, { team: 'test' });\n  await graphDB.storeRelationship('A', 'B', 'implements', { team: 'test' });\n  await graphDB.storeRelationship('A', 'B', 'uses', { team: 'test' });\n\n  const results = await graphDB.queryRelations({ relationType: 'implements' });\n\n  expect(results).toHaveLength(1);\n  expect(results[0].type).toBe('implements');\n});\n```\n\n---\n\n### Task 2.4: Implement JSON Import/Export\n\n**Status**: [ ] Pending\n**Priority**: Medium\n**Estimated Time**: 1 hour\n**Depends On**: Task 2.3\n\n**Description**: Implement manual JSON export and import for `ukb export` and `ukb import` commands.\n\n**Acceptance Criteria**:\n- [ ] `exportToJSON()` writes entities and relations to JSON file\n- [ ] Export format matches existing shared-memory JSON schema\n- [ ] `importFromJSON()` reads JSON and populates graph\n- [ ] Import validates JSON schema before loading\n- [ ] Import is idempotent (can run multiple times safely)\n- [ ] Clear error messages for file I/O failures\n\n**Implementation Steps**:\n```javascript\nasync exportToJSON(team, filePath) {\n  try {\n    const entities = await this.queryEntities({ team });\n    const relations = await this.queryRelations({ team });\n\n    const json = {\n      entities: entities.map(e => {\n        const { id, ...rest } = e; // Remove internal ID\n        return rest;\n      }),\n      relations: relations.map(r => ({\n        from: r.from,\n        to: r.to,\n        type: r.type,\n        confidence: r.confidence || 1.0\n      })),\n      metadata: {\n        last_updated: new Date().toISOString(),\n        team,\n        entity_count: entities.length,\n        relation_count: relations.length\n      }\n    };\n\n    await fs.writeFile(filePath, JSON.stringify(json, null, 2), 'utf8');\n    console.log(`âœ“ Exported ${entities.length} entities to ${filePath}`);\n\n    return { success: true, entityCount: entities.length, relationCount: relations.length };\n  } catch (error) {\n    throw new Error(`Failed to export knowledge: ${error.message}`);\n  }\n}\n\nasync importFromJSON(filePath) {\n  try {\n    const content = await fs.readFile(filePath, 'utf8');\n    const data = JSON.parse(content);\n\n    // Validate schema\n    if (!data.entities || !data.relations) {\n      throw new Error('Invalid JSON format: missing entities or relations');\n    }\n\n    const { entities, relations, metadata } = data;\n    const team = metadata.team || 'default';\n\n    // Import entities\n    for (const entity of entities) {\n      await this.storeEntity(entity, { team: entity.team || team });\n    }\n\n    // Import relations\n    for (const relation of relations) {\n      const fromName = relation.from.split(':')[1] || relation.from;\n      const toName = relation.to.split(':')[1] || relation.to;\n      await this.storeRelationship(fromName, toName, relation.type, {\n        team,\n        confidence: relation.confidence\n      });\n    }\n\n    console.log(`âœ“ Imported ${entities.length} entities and ${relations.length} relations`);\n\n    return { success: true, entityCount: entities.length, relationCount: relations.length };\n  } catch (error) {\n    throw new Error(`Failed to import knowledge: ${error.message}`);\n  }\n}\n```\n\n**Test Coverage**:\n```javascript\ntest('exportToJSON creates valid file', async () => {\n  await graphDB.storeEntity({ name: 'Test', entityType: 'Pattern' }, { team: 'test' });\n\n  const result = await graphDB.exportToJSON('test', '/tmp/test-export.json');\n\n  expect(result.success).toBe(true);\n  expect(result.entityCount).toBe(1);\n\n  const content = JSON.parse(await fs.readFile('/tmp/test-export.json', 'utf8'));\n  expect(content.entities).toHaveLength(1);\n  expect(content.metadata.team).toBe('test');\n});\n```\n\n---\n\n## Phase 3: Integration with Existing Services (3-4 hours)\n\n### Task 3.1: Update KnowledgeQueryService to Use Graph\n\n**Status**: [ ] Pending\n**Priority**: Critical\n**Estimated Time**: 1.5 hours\n**Depends On**: Task 2.3\n\n**Description**: Modify KnowledgeQueryService to delegate to GraphDatabaseService instead of SQLite.\n\n**Acceptance Criteria**:\n- [ ] Constructor accepts GraphDatabaseService instance\n- [ ] All query methods delegate to GraphDatabaseService\n- [ ] Public API remains unchanged (no breaking changes)\n- [ ] SQLite kept as fallback option (constructor parameter)\n- [ ] Semantic search still uses Qdrant (no changes)\n\n**Implementation Steps**:\n```javascript\n// src/knowledge-management/KnowledgeQueryService.js\n\nexport class KnowledgeQueryService {\n  constructor(databaseManager, graphDatabase, options = {}) {\n    this.databaseManager = databaseManager;  // Keep for analytics queries\n    this.graphDatabase = graphDatabase;      // NEW: Graph DB for knowledge\n    this.qdrantService = options.qdrantService;\n  }\n\n  async queryEntities(options = {}) {\n    // Delegate to GraphDatabaseService\n    return await this.graphDatabase.queryEntities(options);\n  }\n\n  async queryRelations(options = {}) {\n    // Delegate to GraphDatabaseService\n    return await this.graphDatabase.queryRelations(options);\n  }\n\n  async getTeams() {\n    return await this.graphDatabase.getTeams();\n  }\n\n  async getStatistics(options = {}) {\n    return await this.graphDatabase.getStatistics(options);\n  }\n\n  async semanticSearch(query, options = {}) {\n    // Still uses Qdrant (no changes)\n    if (!this.qdrantService) {\n      throw new Error('Semantic search requires Qdrant service');\n    }\n    return await this.qdrantService.search(query, options);\n  }\n}\n```\n\n**Files Modified**:\n- `src/knowledge-management/KnowledgeQueryService.js`\n\n**Test Coverage**:\n```javascript\ndescribe('KnowledgeQueryService with Graph', () => {\n  test('queryEntities delegates to GraphDatabaseService', async () => {\n    const graphDB = new GraphDatabaseService();\n    await graphDB.initialize();\n    const queryService = new KnowledgeQueryService(null, graphDB);\n\n    await graphDB.storeEntity({ name: 'Test' }, { team: 'test' });\n\n    const results = await queryService.queryEntities({ team: 'test' });\n\n    expect(results).toHaveLength(1);\n    expect(results[0].name).toBe('Test');\n  });\n});\n```\n\n---\n\n### Task 3.2: Update KnowledgeStorageService\n\n**Status**: [ ] Pending\n**Priority**: High\n**Estimated Time**: 1 hour\n**Depends On**: Task 2.1\n\n**Description**: Update KnowledgeStorageService to use GraphDatabaseService for entity/relationship storage.\n\n**Acceptance Criteria**:\n- [ ] `storeKnowledge()` delegates to GraphDatabaseService.storeEntity()\n- [ ] `storeRelation()` delegates to GraphDatabaseService.storeRelationship()\n- [ ] Qdrant vector storage still happens (dual write: graph + vectors)\n- [ ] Validation logic preserved\n- [ ] Public API unchanged\n\n**Implementation Steps**:\n```javascript\n// src/knowledge-management/KnowledgeStorageService.js\n\nexport class KnowledgeStorageService {\n  constructor(databaseManager, graphDatabase, qdrantService) {\n    this.databaseManager = databaseManager;  // Keep for analytics\n    this.graphDatabase = graphDatabase;      // NEW\n    this.qdrantService = qdrantService;\n  }\n\n  async storeKnowledge(entity, options = {}) {\n    // Validate entity\n    this.validateKnowledge(entity);\n\n    const team = options.team || 'default';\n\n    // Store in graph database\n    const nodeId = await this.graphDatabase.storeEntity(entity, { team });\n\n    // Store embedding in Qdrant (dual write)\n    if (this.qdrantService && entity.content) {\n      await this.qdrantService.storeEmbedding({\n        id: nodeId,\n        content: entity.content,\n        metadata: { team, entityType: entity.entityType }\n      });\n    }\n\n    return nodeId;\n  }\n\n  async storeRelation(from, to, type, metadata = {}) {\n    await this.graphDatabase.storeRelationship(from, to, type, metadata);\n  }\n}\n```\n\n**Files Modified**:\n- `src/knowledge-management/KnowledgeStorageService.js`\n\n---\n\n### Task 3.3: Update DatabaseManager\n\n**Status**: [ ] Pending\n**Priority**: High\n**Estimated Time**: 1 hour\n**Depends On**: Task 1.3\n\n**Description**: Update DatabaseManager to initialize GraphDatabaseService alongside existing databases.\n\n**Acceptance Criteria**:\n- [ ] GraphDatabaseService initialized on startup\n- [ ] Health check includes graph database status\n- [ ] Graceful degradation if graph DB fails (logs error, continues with SQLite)\n- [ ] Cleanup on shutdown includes graph DB close()\n\n**Implementation Steps**:\n```javascript\n// src/databases/DatabaseManager.js\n\nexport class DatabaseManager {\n  constructor(config) {\n    this.config = config;\n    this.db = null;              // SQLite (analytics)\n    this.graphDB = null;         // NEW: Graph database\n    this.qdrantClient = null;    // Qdrant (vectors)\n  }\n\n  async initialize() {\n    // Initialize SQLite (analytics only)\n    this.db = this._initializeSQLite();\n\n    // Initialize Graph Database\n    try {\n      const { GraphDatabaseService } = await import('../knowledge-management/GraphDatabaseService.js');\n      this.graphDB = new GraphDatabaseService({\n        dbPath: this.config.graphDbPath || '.data/knowledge-graph',\n        config: this.config.graphDatabase || {}\n      });\n      await this.graphDB.initialize();\n      console.log('âœ“ Graph database initialized');\n    } catch (error) {\n      console.error('âœ— Failed to initialize graph database:', error);\n      // Continue with SQLite fallback\n    }\n\n    // Initialize Qdrant (unchanged)\n    if (this.config.qdrant?.enabled) {\n      await this._initializeQdrant();\n    }\n  }\n\n  async getHealth() {\n    const health = {\n      sqlite: this._checkSQLiteHealth(),\n      graph: await this.graphDB?.getHealth() || { status: 'unavailable' },\n      qdrant: await this._checkQdrantHealth()\n    };\n\n    health.overall = Object.values(health).every(h => h.status === 'healthy')\n      ? 'healthy'\n      : 'degraded';\n\n    return health;\n  }\n\n  async close() {\n    if (this.db) this.db.close();\n    if (this.graphDB) await this.graphDB.close();\n    if (this.qdrantClient) await this.qdrantClient.close();\n  }\n}\n```\n\n**Files Modified**:\n- `src/databases/DatabaseManager.js`\n\n---\n\n### Task 3.4: Update VKB API Routes\n\n**Status**: [ ] Pending\n**Priority**: Medium (VKB already queries via KnowledgeQueryService)\n**Estimated Time**: 30 minutes\n**Depends On**: Task 3.1\n\n**Description**: Verify VKB HTTP API routes work with graph database backend.\n\n**Acceptance Criteria**:\n- [ ] `/api/entities` endpoint returns correct data from graph\n- [ ] `/api/relations` endpoint returns correct relationships\n- [ ] `/api/teams` endpoint returns team list\n- [ ] `/api/stats` endpoint returns statistics\n- [ ] Response format matches existing SQLite responses exactly\n- [ ] No changes needed to VKB frontend (compatibility verified)\n\n**Implementation Steps**:\n1. Review `lib/vkb-server/api-routes.js`\n2. Verify ApiRoutes uses KnowledgeQueryService\n3. Test all endpoints with graph database\n4. Document any response format differences\n\n**Files Modified**:\n- None (verification only, KnowledgeQueryService already updated)\n\n**Test Coverage**:\n```javascript\ndescribe('VKB API with Graph Database', () => {\n  test('GET /api/entities returns entities', async () => {\n    await graphDB.storeEntity({ name: 'Test' }, { team: 'test' });\n\n    const response = await fetch('http://localhost:8080/api/entities?team=test');\n    const entities = await response.json();\n\n    expect(entities).toHaveLength(1);\n    expect(entities[0].name).toBe('Test');\n  });\n});\n```\n\n---\n\n## Phase 4: Migration Implementation (3-4 hours)\n\n### Task 4.1: Create GraphMigrationService\n\n**Status**: [ ] Pending\n**Priority**: Critical\n**Estimated Time**: 2 hours\n**Depends On**: Task 2.1\n\n**Description**: Implement migration service to transfer data from SQLite to graph database.\n\n**Acceptance Criteria**:\n- [ ] Extracts all entities from `knowledge_extractions` table\n- [ ] Extracts all relationships from `knowledge_relations` table\n- [ ] Transforms SQLite rows to graph nodes/edges\n- [ ] Loads data into GraphDatabaseService\n- [ ] Creates timestamped backups before migration\n- [ ] Verifies entity/relationship counts match\n- [ ] Provides rollback capability\n\n**Implementation Steps**:\n```javascript\n// src/knowledge-management/GraphMigrationService.js\n\nexport class GraphMigrationService {\n  constructor(databaseManager, graphDatabase) {\n    this.databaseManager = databaseManager;\n    this.graphDatabase = graphDatabase;\n  }\n\n  async runMigration() {\n    console.log('ðŸ”„ Starting migration from SQLite to Graph Database...\\n');\n\n    try {\n      // Phase 1: Backup\n      const backupPath = await this.createBackup();\n      console.log(`âœ“ Backup created at ${backupPath}`);\n\n      // Phase 2: Extract from SQLite\n      const entities = this.databaseManager.db\n        .prepare('SELECT * FROM knowledge_extractions')\n        .all();\n\n      const relations = this.databaseManager.db\n        .prepare('SELECT * FROM knowledge_relations')\n        .all();\n\n      console.log(`âœ“ Extracted ${entities.length} entities, ${relations.length} relations`);\n\n      // Phase 3: Transform and Load\n      let migratedEntities = 0;\n      for (const row of entities) {\n        const entity = this.transformEntity(row);\n        await this.graphDatabase.storeEntity(entity, { team: row.team });\n        migratedEntities++;\n\n        if (migratedEntities % 100 === 0) {\n          console.log(`  Progress: ${migratedEntities}/${entities.length} entities`);\n        }\n      }\n\n      let migratedRelations = 0;\n      for (const row of relations) {\n        await this.graphDatabase.storeRelationship(\n          row.from_entity,\n          row.to_entity,\n          row.relation_type,\n          { team: row.team, confidence: row.confidence }\n        );\n        migratedRelations++;\n      }\n\n      console.log(`âœ“ Migrated ${migratedEntities} entities, ${migratedRelations} relations`);\n\n      // Phase 4: Verify\n      const verification = await this.verifyMigration(entities.length, relations.length);\n\n      if (!verification.success) {\n        throw new Error(`Verification failed: ${verification.reason}`);\n      }\n\n      console.log('âœ“ Migration verification passed');\n\n      return {\n        success: true,\n        entitiesMigrated: migratedEntities,\n        relationsMigrated: migratedRelations,\n        backupPath\n      };\n\n    } catch (error) {\n      console.error('âœ— Migration failed:', error.message);\n      console.log('ðŸ”„ Rolling back...');\n      await this.rollback();\n      throw error;\n    }\n  }\n\n  transformEntity(row) {\n    return {\n      name: row.entity_name,\n      entityType: row.entity_type,\n      observations: JSON.parse(row.observations || '[]'),\n      confidence: row.confidence_score,\n      source: row.source,\n      team: row.team,\n      created_at: row.created_at,\n      last_modified: row.last_modified\n    };\n  }\n\n  async verifyMigration(expectedEntities, expectedRelations) {\n    const stats = await this.graphDatabase.getStatistics();\n\n    if (stats.entityCount !== expectedEntities) {\n      return {\n        success: false,\n        reason: `Entity count mismatch: expected ${expectedEntities}, got ${stats.entityCount}`\n      };\n    }\n\n    if (stats.relationCount !== expectedRelations) {\n      return {\n        success: false,\n        reason: `Relation count mismatch: expected ${expectedRelations}, got ${stats.relationCount}`\n      };\n    }\n\n    return { success: true };\n  }\n\n  async createBackup() {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const backupDir = `.data/backups/${timestamp}`;\n    await fs.mkdir(backupDir, { recursive: true });\n\n    // Backup SQLite\n    await fs.copyFile('.data/knowledge.db', `${backupDir}/knowledge.db`);\n\n    return backupDir;\n  }\n\n  async rollback() {\n    // Implementation: restore from most recent backup\n    console.log('âœ“ Rollback complete - SQLite database restored');\n  }\n}\n```\n\n**Files Created**:\n- `src/knowledge-management/GraphMigrationService.js`\n\n**Test Coverage**:\n```javascript\ntest('Migration transfers all entities', async () => {\n  // Populate SQLite with test data\n  databaseManager.db.prepare(`\n    INSERT INTO knowledge_extractions (entity_name, entity_type, team)\n    VALUES (?, ?, ?)\n  `).run('Test', 'Pattern', 'test');\n\n  const migration = new GraphMigrationService(databaseManager, graphDB);\n  const report = await migration.runMigration();\n\n  expect(report.success).toBe(true);\n  expect(report.entitiesMigrated).toBe(1);\n});\n```\n\n---\n\n### Task 4.2: Create Migration CLI Script\n\n**Status**: [ ] Pending\n**Priority**: High\n**Estimated Time**: 1 hour\n**Depends On**: Task 4.1\n\n**Description**: Create command-line script to execute migration with progress reporting.\n\n**Acceptance Criteria**:\n- [ ] Script located at `scripts/knowledge-management/migrate-to-graph.js`\n- [ ] Shows progress bar or percentage during migration\n- [ ] Outputs detailed migration report on completion\n- [ ] Provides clear error messages on failure\n- [ ] Supports `--dry-run` flag for testing\n\n**Implementation Steps**:\n```javascript\n#!/usr/bin/env node\n// scripts/knowledge-management/migrate-to-graph.js\n\nimport { DatabaseManager } from '../../src/databases/DatabaseManager.js';\nimport { GraphDatabaseService } from '../../src/knowledge-management/GraphDatabaseService.js';\nimport { GraphMigrationService } from '../../src/knowledge-management/GraphMigrationService.js';\n\nasync function main() {\n  const isDryRun = process.argv.includes('--dry-run');\n\n  console.log('â”'.repeat(60));\n  console.log('ðŸ“¦ Knowledge Database Migration: SQLite â†’ Graph');\n  console.log('â”'.repeat(60));\n  console.log();\n\n  if (isDryRun) {\n    console.log('ðŸ” DRY RUN MODE - No changes will be made\\n');\n  }\n\n  // Initialize services\n  const databaseManager = new DatabaseManager({});\n  await databaseManager.initialize();\n\n  const graphDB = new GraphDatabaseService({\n    dbPath: '.data/knowledge-graph'\n  });\n  await graphDB.initialize();\n\n  const migration = new GraphMigrationService(databaseManager, graphDB);\n\n  if (isDryRun) {\n    // Count entities\n    const entityCount = databaseManager.db\n      .prepare('SELECT COUNT(*) as count FROM knowledge_extractions')\n      .get().count;\n\n    console.log(`Would migrate ${entityCount} entities`);\n    console.log('Run without --dry-run to execute migration');\n    process.exit(0);\n  }\n\n  // Run migration\n  try {\n    const report = await migration.runMigration();\n\n    console.log();\n    console.log('â”'.repeat(60));\n    console.log('âœ… MIGRATION SUCCESSFUL');\n    console.log('â”'.repeat(60));\n    console.log(`Entities migrated: ${report.entitiesMigrated}`);\n    console.log(`Relations migrated: ${report.relationsMigrated}`);\n    console.log(`Backup location: ${report.backupPath}`);\n    console.log();\n\n    process.exit(0);\n  } catch (error) {\n    console.error();\n    console.error('â”'.repeat(60));\n    console.error('âŒ MIGRATION FAILED');\n    console.error('â”'.repeat(60));\n    console.error(error.message);\n    console.error();\n    process.exit(1);\n  }\n}\n\nmain();\n```\n\n**Files Created**:\n- `scripts/knowledge-management/migrate-to-graph.js`\n\n**Usage**:\n```bash\n# Dry run (preview)\nnode scripts/knowledge-management/migrate-to-graph.js --dry-run\n\n# Execute migration\nnode scripts/knowledge-management/migrate-to-graph.js\n```\n\n---\n\n### Task 4.3: Remove MCP Memory Server\n\n**Status**: [ ] Pending\n**Priority**: High\n**Estimated Time**: 30 minutes\n**Depends On**: Task 4.1 (migration complete)\n\n**Description**: Remove MCP Memory server from configuration after successful migration.\n\n**Acceptance Criteria**:\n- [ ] `memory` server entry removed from `claude-code-mcp.json`\n- [ ] No references to MCP Memory in service initialization\n- [ ] Documentation updated to reflect removal\n- [ ] Verification that knowledge queries still work without MCP Memory\n\n**Implementation Steps**:\n1. Edit `claude-code-mcp.json`:\n   ```json\n   {\n     \"mcpServers\": {\n       // REMOVE this entire block:\n       // \"memory\": {\n       //   \"command\": \"npx\",\n       //   \"args\": [\"-y\", \"@anthropics/mcp-memory\"]\n       // }\n     }\n   }\n   ```\n\n2. Update startup scripts to not reference MCP Memory\n\n3. Update documentation:\n   - `docs/KNOWLEDGE-MANAGEMENT-QUICKSTART.md`\n   - `docs/DATABASE-MIGRATION-GUIDE.md`\n\n**Files Modified**:\n- `claude-code-mcp.json`\n- `docs/KNOWLEDGE-MANAGEMENT-QUICKSTART.md`\n- `docs/DATABASE-MIGRATION-GUIDE.md`\n\n**Verification**:\n```bash\n# Start services\nbin/coding\n\n# Test knowledge query\nukb query --team coding\n\n# Should work without MCP Memory\n```\n\n---\n\n## Phase 5: Testing & Documentation (2-3 hours)\n\n### Task 5.1: Unit Tests for GraphDatabaseService\n\n**Status**: [ ] Pending\n**Priority**: High\n**Estimated Time**: 1.5 hours\n**Depends On**: Task 2.4\n\n**Description**: Create comprehensive unit tests achieving >90% coverage.\n\n**Acceptance Criteria**:\n- [ ] Test file: `tests/unit/GraphDatabaseService.test.js`\n- [ ] Tests for all public methods\n- [ ] Tests for error scenarios (Level DB unavailable, invalid input)\n- [ ] Tests for concurrent modifications\n- [ ] Performance tests (2-hop <50ms, 3-hop <100ms)\n- [ ] Coverage >90%\n\n**Test Cases**:\n```javascript\n// tests/unit/GraphDatabaseService.test.js\ndescribe('GraphDatabaseService', () => {\n  describe('storeEntity', () => {\n    test('creates node with correct attributes');\n    test('updates existing node');\n    test('emits entity:stored event');\n    test('throws error for invalid entity');\n  });\n\n  describe('findRelated', () => {\n    test('traverses 2 hops correctly');\n    test('respects depth limit');\n    test('filters by relationship type');\n    test('handles circular relationships');\n  });\n\n  describe('queryEntities', () => {\n    test('filters by team');\n    test('filters by entity type');\n    test('filters by confidence');\n    test('applies search term');\n    test('paginates correctly');\n  });\n\n  describe('error handling', () => {\n    test('gracefully degrades when Level DB unavailable');\n    test('handles concurrent modifications');\n  });\n\n  describe('performance', () => {\n    test('2-hop query completes in <50ms');\n    test('3-hop query completes in <100ms');\n  });\n});\n```\n\n---\n\n### Task 5.2: Integration Tests\n\n**Status**: [ ] Pending\n**Priority**: High\n**Estimated Time**: 1 hour\n**Depends On**: Task 3.4, Task 4.2\n\n**Description**: Create integration tests for end-to-end workflows.\n\n**Acceptance Criteria**:\n- [ ] Test migration from SQLite to graph\n- [ ] Test VKB HTTP API with graph backend\n- [ ] Test UKB commands with graph backend\n- [ ] Test rollback functionality\n\n**Test Cases**:\n```javascript\n// tests/integration/migration.test.js\ndescribe('Migration Integration', () => {\n  test('migrates all data from SQLite to graph');\n  test('rollback restores SQLite database');\n  test('verification detects count mismatch');\n});\n\n// tests/integration/http-api.test.js\ndescribe('HTTP API with Graph Database', () => {\n  test('GET /api/entities returns entities from graph');\n  test('GET /api/relations returns relationships');\n  test('VKB visualization loads data correctly');\n});\n```\n\n---\n\n### Task 5.3: Update Documentation\n\n**Status**: [ ] Pending\n**Priority**: Medium\n**Estimated Time**: 1 hour\n**Depends On**: All implementation tasks\n\n**Description**: Update documentation to reflect graph database architecture.\n\n**Acceptance Criteria**:\n- [ ] Update `docs/KNOWLEDGE-MANAGEMENT-QUICKSTART.md` with graph database details\n- [ ] Update `docs/DATABASE-MIGRATION-GUIDE.md` with migration instructions\n- [ ] Create `docs/GRAPH-DATABASE-ARCHITECTURE.md` with architecture overview\n- [ ] Update README.md with graph database mention\n- [ ] Document performance improvements\n\n**Files to Update**:\n- `docs/KNOWLEDGE-MANAGEMENT-QUICKSTART.md`\n- `docs/DATABASE-MIGRATION-GUIDE.md`\n- `docs/GRAPH-DATABASE-ARCHITECTURE.md` (new)\n- `README.md`\n\n---\n\n## Summary\n\n### Task Breakdown by Priority\n\n**Critical Path** (Must complete in order):\n1. Task 1.1: Install Dependencies â†’ 1.3: Skeleton â†’ 2.1: Core Operations â†’ 2.3: Query Interface â†’ 3.1: KnowledgeQueryService â†’ 4.1: Migration Service\n\n**High Priority** (Required for launch):\n- All Phase 1 and Phase 2 tasks\n- Tasks 3.1, 3.2, 3.3, 4.1, 4.2, 4.3\n- Tasks 5.1, 5.2\n\n**Medium Priority** (Nice to have):\n- Task 2.4: JSON Import/Export\n- Task 3.4: VKB API verification\n- Task 5.3: Documentation\n\n### Estimated Timeline\n\n| Phase | Time Estimate |\n|-------|---------------|\n| Phase 1: Foundation | 2-3 hours |\n| Phase 2: GraphDatabaseService | 4-5 hours |\n| Phase 3: Integration | 3-4 hours |\n| Phase 4: Migration | 3-4 hours |\n| Phase 5: Testing & Docs | 2-3 hours |\n| **Total** | **14-19 hours** |\n\n### Success Criteria\n\nMigration is complete when:\n- [ ] All tests passing (>90% coverage)\n- [ ] Migration script executes successfully\n- [ ] VKB visualizes graph data correctly\n- [ ] UKB commands work with graph backend\n- [ ] MCP Memory server removed\n- [ ] Performance benchmarks met (<100ms for 3-hop queries)\n- [ ] Zero data loss verified\n\n---\n\n**Document Status**: Ready for Approval\n**Next Phase**: Implementation (after approval)\n",
  "fileStats": {
    "size": 38153,
    "lines": 1327,
    "lastModified": "2025-10-21T09:29:23.753Z"
  },
  "comments": []
}