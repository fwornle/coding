{
  "id": "snapshot_1761037489870_nd97onoyx",
  "approvalId": "approval_1761037489866_02d444zmo",
  "approvalTitle": "Graph Storage Migration - Design Document",
  "version": 1,
  "timestamp": "2025-10-21T09:04:49.870Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design implements a **graph-first knowledge storage architecture** that replaces SQLite relational tables with a Graphology + Level graph database while maintaining Qdrant for vector search and SQLite for analytics. The architecture achieves agent-agnostic operation by removing the MCP Memory server dependency and implements automatic JSON export for version control.\n\n### Key Design Principles\n\n1. **Graph-Native Storage**: Knowledge entities and relationships stored natively in graph structure\n2. **Agent Agnostic**: Works with any AI coding assistant (Claude Code, Copilot, Cursor, Aider)\n3. **Auto-Sync Architecture**: Graph modifications automatically trigger batched JSON exports\n4. **Clean Separation**: Graph (knowledge), Qdrant (vectors), SQLite (analytics) - each optimized for its purpose\n5. **Zero Data Loss**: Comprehensive migration with verification and rollback capability\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n**Configuration-Driven Architecture** (§2.3):\n- Graph database configuration integrated into existing `config/` structure\n- Environment variables for database paths and team scoping\n- Validation at startup following established patterns\n\n**Data Architecture** (§2.5.1):\n```javascript\n// Aligns with existing multi-database pattern\n{\n  \"databases\": {\n    \"graph\": \"Graphology + Level (knowledge)\",\n    \"vector\": \"Qdrant (semantic search)\",\n    \"relational\": \"SQLite (analytics only)\"\n  }\n}\n```\n\n**Performance Standards** (§2.3):\n- <100ms for knowledge operations (graph traversal is O(1) vs SQLite O(n*m) JOINs)\n- <5% CPU during normal operation\n- <150MB memory (acceptable for in-memory graph)\n\n**Agent-Agnostic Design Pattern** (§2.2.2):\n- Remove MCP Memory server dependency\n- Direct graph database access via standard Node.js modules\n- No protocol-specific integrations required\n\n### Project Structure (structure.md)\n\n**Modular Design** (§2.1):\n```\nsrc/\n├── knowledge-management/\n│   ├── GraphDatabaseService.js      # NEW: Graph operations\n│   ├── GraphMigrationService.js     # NEW: One-time migration\n│   ├── GraphExportService.js        # NEW: Auto-sync to JSON\n│   └── KnowledgeStorageService.js   # UPDATED: Orchestrator\n├── databases/\n│   └── DatabaseManager.js           # UPDATED: Add graph DB\n```\n\n**Single Responsibility Principle** (§2.9):\n- **GraphDatabaseService**: Graph CRUD operations only\n- **GraphMigrationService**: Migration logic isolated, one-time use\n- **GraphExportService**: JSON export logic, reusable\n- **KnowledgeStorageService**: High-level orchestration, unchanged API\n\n**File Organization** (§2.9.4):\n- Graph database components in `src/knowledge-management/`\n- Migration scripts in `scripts/knowledge-management/`\n- Configuration in `config/graph-database-config.json`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n**1. MemoryFallbackService** (`lib/fallbacks/memory-fallback.js`):\n- ✅ **Already uses Graphology!**\n- ✅ Has team-based file path logic: `_getTeamFilePath()`\n- ✅ Has JSON serialization: `saveGraph()`, `loadGraph()`\n- ✅ Has shared-memory sync: `syncToSharedMemory()`\n- **Reuse Strategy**: Extract patterns, adapt for Level persistence\n\n**2. KnowledgeStorageService** (`src/knowledge-management/KnowledgeStorageService.js`):\n- ✅ Has entity validation: `validateKnowledge()`\n- ✅ Has embedding generation: `generateEmbeddings()`\n- ✅ Has transactional storage: `storeTransactional()`\n- **Integration Strategy**: Update to use GraphDatabaseService, maintain existing API\n\n**3. DatabaseManager** (`src/databases/DatabaseManager.js`):\n- ✅ Has SQLite schema management: `createSQLiteSchemas()`\n- ✅ Has health checking: `getHealth()`\n- ✅ Has stats collection: `getStats()`\n- **Integration Strategy**: Add `initializeGraphDB()`, keep SQLite for analytics\n\n**4. Package Dependencies**:\n- ✅ Graphology already installed (v0.25.4)\n- ✅ graphology-utils already installed (v2.5.2)\n- ✅ Level already installed (v10.0.0)\n- ✅ LevelGraph installed but **will not be used** (Node.js 24 incompatibility)\n\n### Integration Points\n\n**1. KnowledgeStorageService → GraphDatabaseService**:\n```javascript\n// Current (SQLite):\nawait this.databaseManager.storeKnowledgeExtraction(knowledge)\n\n// After (Graph):\nawait this.graphDatabase.storeEntity(knowledge)\n```\n\n**2. VKB Visualization → JSON Files**:\n- No changes needed! VKB reads `shared-memory-*.json` files\n- GraphExportService writes same format\n- Backward compatible\n\n**3. UKB Command → KnowledgeStorageService**:\n- No changes needed! UKB uses KnowledgeStorageService API\n- API remains unchanged\n- Internal implementation swaps SQLite → Graph\n\n**4. Qdrant Integration**:\n- Unchanged! Embeddings still stored in Qdrant\n- GraphDatabaseService coordinates with Qdrant via DatabaseManager\n- Dual-database strategy maintained\n\n## Architecture\n\n### System Architecture\n\n```mermaid\ngraph TB\n    subgraph \"User Interfaces\"\n        UKB[UKB CLI]\n        VKB[VKB Web Viewer]\n        LSL[Live Session Logger]\n    end\n\n    subgraph \"Orchestration Layer\"\n        KSS[KnowledgeStorageService<br/>Unchanged API]\n    end\n\n    subgraph \"New Graph Layer\"\n        GDS[GraphDatabaseService<br/>Graphology + Level]\n        GES[GraphExportService<br/>Auto-sync to JSON]\n    end\n\n    subgraph \"Existing Layers\"\n        DBM[DatabaseManager]\n        QDR[Qdrant<br/>Vector Search]\n        SQL[SQLite<br/>Analytics Only]\n    end\n\n    subgraph \"Persistent Storage\"\n        GFILE[\".data/knowledge-graph/<br/>Level DB Files\"]\n        JFILE[\"shared-memory-*.json<br/>Git-tracked\"]\n        QFILE[\"Qdrant Collections\"]\n        SFILE[\".data/knowledge.db<br/>Budget/Metrics\"]\n    end\n\n    UKB --> KSS\n    LSL --> KSS\n    VKB --> JFILE\n\n    KSS --> GDS\n    KSS --> DBM\n\n    GDS --> GFILE\n    GDS -.Auto-sync.-> GES\n    GES --> JFILE\n\n    DBM --> QDR\n    DBM --> SQL\n\n    QDR --> QFILE\n    SQL --> SFILE\n\n    style GDS fill:#90EE90\n    style GES fill:#90EE90\n    style KSS fill:#FFE4B5\n    style JFILE fill:#87CEEB\n```\n\n### Migration Architecture\n\n```mermaid\nsequenceDiagram\n    participant CLI as Migration CLI\n    participant GMS as GraphMigrationService\n    participant SQL as SQLite DB\n    participant GDS as GraphDatabaseService\n    participant GES as GraphExportService\n    participant FS as File System\n\n    CLI->>GMS: runMigration()\n\n    Note over GMS: Phase 1: Backup\n    GMS->>SQL: Export all knowledge data\n    GMS->>FS: Write backup files (.data/backups/)\n\n    Note over GMS: Phase 2: Extract\n    GMS->>SQL: SELECT * FROM knowledge_extractions\n    GMS->>SQL: SELECT * FROM knowledge_relations\n\n    Note over GMS: Phase 3: Transform\n    loop For each entity\n        GMS->>GMS: Transform SQLite row → Graph node\n    end\n    loop For each relation\n        GMS->>GMS: Transform SQLite row → Graph edge\n    end\n\n    Note over GMS: Phase 4: Load\n    GMS->>GDS: storeEntity(entity) × N\n    GDS->>FS: Persist to Level DB\n    GMS->>GDS: storeRelationship(edge) × M\n\n    Note over GMS: Phase 5: Verify\n    GMS->>SQL: COUNT(entities)\n    GMS->>GDS: graph.order (node count)\n    GMS->>GMS: Verify counts match\n    GMS->>GMS: Sample 10 entities, verify attributes\n\n    alt Verification passes\n        Note over GMS: Phase 6: Export\n        GMS->>GES: exportAllTeams()\n        GES->>FS: Write shared-memory-*.json files\n        GMS->>CLI: ✅ Success report\n    else Verification fails\n        GMS->>FS: Restore from backup\n        GMS->>CLI: ❌ Rollback, error report\n    end\n```\n\n### Auto-Sync Architecture\n\n```mermaid\nsequenceDiagram\n    participant App as Application\n    participant GDS as GraphDatabaseService\n    participant GES as GraphExportService\n    participant Batch as Batch Queue\n    participant FS as File System\n\n    Note over GDS,GES: Multiple modifications within 5 seconds\n\n    App->>GDS: storeEntity(entity1)\n    GDS->>Batch: Queue export for team 'coding'\n    Note over Batch: Timer starts (5s)\n\n    App->>GDS: storeEntity(entity2)\n    GDS->>Batch: Queue export for team 'coding'\n    Note over Batch: Reset timer (5s)\n\n    App->>GDS: storeRelationship(edge1)\n    GDS->>Batch: Queue export for team 'coding'\n    Note over Batch: Reset timer (5s)\n\n    Note over Batch: 5 seconds elapsed, no new modifications\n\n    Batch->>GES: triggerExport(team='coding')\n    GES->>GDS: getAllEntitiesForTeam('coding')\n    GES->>GDS: getAllRelationshipsForTeam('coding')\n    GES->>GES: Build JSON structure\n    GES->>FS: Write shared-memory-coding.json\n\n    alt Export succeeds\n        GES->>Batch: ✅ Clear queue for 'coding'\n    else Export fails\n        Note over GES: Retry #1 (exponential backoff)\n        GES->>FS: Write shared-memory-coding.json\n        alt Still fails\n            Note over GES: Retry #2\n            alt Still fails\n                GES->>Batch: ❌ Log error, clear queue\n            end\n        end\n    end\n```\n\n## Components and Interfaces\n\n### Component 1: GraphDatabaseService\n\n**Purpose**: Core graph database operations using Graphology (in-memory) + Level (persistence)\n\n**File Location**: `src/knowledge-management/GraphDatabaseService.js`\n\n**Interfaces**:\n\n```javascript\nclass GraphDatabaseService {\n  /**\n   * Initialize graph database\n   * @returns {Promise<void>}\n   */\n  async initialize();\n\n  /**\n   * Store an entity in the graph\n   * @param {Object} entity - Entity with name, entityType, observations, etc.\n   * @param {Object} options - Storage options (team, confidence, etc.)\n   * @returns {Promise<string>} - Entity ID\n   */\n  async storeEntity(entity, options = {});\n\n  /**\n   * Retrieve an entity by name and team\n   * @param {string} name - Entity name\n   * @param {string} team - Team name\n   * @returns {Promise<Object|null>} - Entity or null if not found\n   */\n  async getEntity(name, team);\n\n  /**\n   * Store a relationship between entities\n   * @param {string} fromName - Source entity name\n   * @param {string} toName - Target entity name\n   * @param {string} relationType - Type of relationship\n   * @param {Object} metadata - Relationship metadata (confidence, etc.)\n   * @returns {Promise<string>} - Edge ID\n   */\n  async storeRelationship(fromName, toName, relationType, metadata = {});\n\n  /**\n   * Find related entities via graph traversal\n   * @param {string} entityName - Starting entity\n   * @param {number} depth - Traversal depth (1-3)\n   * @param {Object} filter - Filter criteria (team, type, etc.)\n   * @returns {Promise<Array>} - Related entities with path info\n   */\n  async findRelated(entityName, depth = 2, filter = {});\n\n  /**\n   * Update an existing entity\n   * @param {string} name - Entity name\n   * @param {string} team - Team name\n   * @param {Object} updates - Fields to update\n   * @returns {Promise<boolean>} - Success status\n   */\n  async updateEntity(name, team, updates);\n\n  /**\n   * Delete an entity and its relationships\n   * @param {string} name - Entity name\n   * @param {string} team - Team name\n   * @returns {Promise<boolean>} - Success status\n   */\n  async deleteEntity(name, team);\n\n  /**\n   * Export all entities for a team\n   * @param {string} team - Team name\n   * @returns {Promise<Object>} - {entities: [], relations: []}\n   */\n  async exportTeam(team);\n\n  /**\n   * Get health status\n   * @returns {Promise<Object>} - Health metrics\n   */\n  async getHealth();\n\n  /**\n   * Close database connections\n   * @returns {Promise<void>}\n   */\n  async close();\n}\n```\n\n**Dependencies**:\n- Graphology (in-memory graph)\n- Level (persistence layer)\n- EventEmitter (for auto-sync events)\n\n**Reuses**:\n- MemoryFallbackService patterns for Graphology operations\n- DatabaseManager health check patterns\n- KnowledgeStorageService validation patterns\n\n**Implementation Details**:\n```javascript\nimport Graph from 'graphology';\nimport { Level } from 'level';\nimport { EventEmitter } from 'events';\n\nclass GraphDatabaseService extends EventEmitter {\n  constructor(config = {}) {\n    super();\n    this.dbPath = config.dbPath || '.data/knowledge-graph';\n    this.graph = new Graph({ multi: true }); // Multiple edges allowed\n    this.levelDB = null;\n    this.initialized = false;\n\n    // Node ID format: {team}:{entityName}\n    // Edge ID format: {fromId}-[{relationType}]->{toId}\n  }\n\n  async initialize() {\n    // Create Level DB for persistence\n    this.levelDB = new Level(this.dbPath, { valueEncoding: 'json' });\n    await this.levelDB.open();\n\n    // Load graph from Level DB\n    await this._loadGraphFromLevel();\n\n    this.initialized = true;\n  }\n\n  async _loadGraphFromLevel() {\n    try {\n      // Load nodes\n      const nodesData = await this.levelDB.get('graph:nodes');\n      for (const node of nodesData) {\n        this.graph.addNode(node.id, node.attributes);\n      }\n\n      // Load edges\n      const edgesData = await this.levelDB.get('graph:edges');\n      for (const edge of edgesData) {\n        this.graph.addEdge(edge.source, edge.target, edge.attributes);\n      }\n    } catch (error) {\n      // First run, empty database\n      console.log('Starting with empty graph database');\n    }\n  }\n\n  async _persistGraphToLevel() {\n    // Serialize nodes\n    const nodes = this.graph.mapNodes((nodeId, attributes) => ({\n      id: nodeId,\n      attributes\n    }));\n    await this.levelDB.put('graph:nodes', nodes);\n\n    // Serialize edges\n    const edges = this.graph.mapEdges((edgeId, attributes, source, target) => ({\n      id: edgeId,\n      source,\n      target,\n      attributes\n    }));\n    await this.levelDB.put('graph:edges', edges);\n  }\n\n  async storeEntity(entity, options = {}) {\n    const team = options.team || 'default';\n    const nodeId = `${team}:${entity.name}`;\n\n    const attributes = {\n      name: entity.name,\n      entityType: entity.entityType,\n      observations: entity.observations || [],\n      significance: entity.significance || 5,\n      tags: entity.tags || [],\n      team,\n      confidence: options.confidence || 1.0,\n      createdAt: new Date().toISOString(),\n      lastModified: new Date().toISOString()\n    };\n\n    if (this.graph.hasNode(nodeId)) {\n      this.graph.mergeNodeAttributes(nodeId, attributes);\n    } else {\n      this.graph.addNode(nodeId, attributes);\n    }\n\n    // Persist to Level\n    await this._persistGraphToLevel();\n\n    // Emit event for auto-sync\n    this.emit('entity:stored', { team, entity: attributes });\n\n    return nodeId;\n  }\n\n  async findRelated(entityName, depth = 2, filter = {}) {\n    const team = filter.team || 'default';\n    const nodeId = `${team}:${entityName}`;\n\n    if (!this.graph.hasNode(nodeId)) {\n      return [];\n    }\n\n    const results = [];\n    const visited = new Set([nodeId]);\n    const queue = [{ id: nodeId, depth: 0, path: [] }];\n\n    while (queue.length > 0) {\n      const current = queue.shift();\n\n      if (current.depth >= depth) continue;\n\n      // Get neighbors (both outbound and inbound edges)\n      const neighbors = this.graph.neighbors(current.id);\n\n      for (const neighborId of neighbors) {\n        if (visited.has(neighborId)) continue;\n        visited.add(neighborId);\n\n        const neighborAttrs = this.graph.getNodeAttributes(neighborId);\n\n        // Apply filters\n        if (filter.entityType && neighborAttrs.entityType !== filter.entityType) {\n          continue;\n        }\n\n        const edge = this.graph.edge(current.id, neighborId);\n        const edgeAttrs = this.graph.getEdgeAttributes(edge);\n\n        results.push({\n          entity: neighborAttrs,\n          depth: current.depth + 1,\n          path: [...current.path, edgeAttrs.relationType],\n          relationshipType: edgeAttrs.relationType\n        });\n\n        queue.push({\n          id: neighborId,\n          depth: current.depth + 1,\n          path: [...current.path, edgeAttrs.relationType]\n        });\n      }\n    }\n\n    return results;\n  }\n}\n```\n\n### Component 2: GraphMigrationService\n\n**Purpose**: One-time migration from SQLite to graph database with verification and rollback\n\n**File Location**: `src/knowledge-management/GraphMigrationService.js`\n\n**Interfaces**:\n\n```javascript\nclass GraphMigrationService {\n  /**\n   * Run complete migration process\n   * @returns {Promise<Object>} - Migration report\n   */\n  async runMigration();\n\n  /**\n   * Create backups of all data\n   * @returns {Promise<void>}\n   */\n  async createBackups();\n\n  /**\n   * Extract data from SQLite\n   * @returns {Promise<Object>} - {entities: [], relationships: []}\n   */\n  async extractFromSQLite();\n\n  /**\n   * Load data into graph database\n   * @param {Object} data - {entities: [], relationships: []}\n   * @returns {Promise<void>}\n   */\n  async loadToGraph(data);\n\n  /**\n   * Verify migration integrity\n   * @returns {Promise<Object>} - Verification results\n   */\n  async verifyMigration();\n\n  /**\n   * Rollback to pre-migration state\n   * @returns {Promise<void>}\n   */\n  async rollback();\n}\n```\n\n**Dependencies**:\n- DatabaseManager (SQLite access)\n- GraphDatabaseService (target database)\n- fs/promises (backup operations)\n\n**Reuses**:\n- DatabaseManager SQLite query patterns\n- Existing backup/restore patterns from MemoryFallbackService\n\n**Migration Flow**:\n1. **Pre-flight checks**: Verify SQLite has data, graph is empty, backups directory exists\n2. **Backup**: Copy `.data/knowledge.db` → `.data/backups/knowledge.db.{timestamp}`\n3. **Extract**: Read all rows from `knowledge_extractions`, `knowledge_relations`\n4. **Transform**: Convert SQLite rows to graph nodes/edges\n5. **Load**: Batch insert into graph database\n6. **Verify**: Compare counts, sample random entities, check relationship integrity\n7. **Export**: Trigger JSON export for all teams\n8. **Cleanup**: Mark SQLite knowledge tables for deprecation (keep for rollback)\n\n### Component 3: GraphExportService\n\n**Purpose**: Auto-sync graph database to JSON files with batching and retry logic\n\n**File Location**: `src/knowledge-management/GraphExportService.js`\n\n**Interfaces**:\n\n```javascript\nclass GraphExportService {\n  /**\n   * Initialize export service with batching\n   * @param {GraphDatabaseService} graphDatabase\n   * @param {Object} options - {batchWindowMs: 5000, maxRetries: 3}\n   */\n  constructor(graphDatabase, options = {});\n\n  /**\n   * Queue export for a team (batched)\n   * @param {string} team - Team name\n   * @returns {void}\n   */\n  queueExport(team);\n\n  /**\n   * Export all teams immediately\n   * @returns {Promise<void>}\n   */\n  async exportAllTeams();\n\n  /**\n   * Export single team to JSON file\n   * @param {string} team - Team name\n   * @returns {Promise<boolean>} - Success status\n   */\n  async exportTeam(team);\n\n  /**\n   * Start listening for graph events\n   * @returns {void}\n   */\n  startAutoSync();\n\n  /**\n   * Stop auto-sync\n   * @returns {void}\n   */\n  stopAutoSync();\n}\n```\n\n**Dependencies**:\n- GraphDatabaseService (data source)\n- fs/promises (file operations)\n- EventEmitter (listening to graph events)\n\n**Reuses**:\n- MemoryFallbackService JSON format (backward compatible!)\n- MemoryFallbackService `_getTeamFilePath()` logic\n\n**Batching Logic**:\n```javascript\nclass GraphExportService {\n  constructor(graphDatabase, options = {}) {\n    this.graphDatabase = graphDatabase;\n    this.batchWindowMs = options.batchWindowMs || 5000; // 5 seconds\n    this.maxRetries = options.maxRetries || 3;\n    this.pendingExports = new Map(); // team -> timer\n  }\n\n  queueExport(team) {\n    // Clear existing timer\n    if (this.pendingExports.has(team)) {\n      clearTimeout(this.pendingExports.get(team));\n    }\n\n    // Set new timer\n    const timer = setTimeout(() => {\n      this.exportTeam(team).catch(console.error);\n      this.pendingExports.delete(team);\n    }, this.batchWindowMs);\n\n    this.pendingExports.set(team, timer);\n  }\n\n  async exportTeam(team) {\n    let attempts = 0;\n    let delay = 1000; // Start with 1 second\n\n    while (attempts < this.maxRetries) {\n      try {\n        const data = await this.graphDatabase.exportTeam(team);\n        const filePath = this._getTeamFilePath(team);\n\n        const json = {\n          entities: data.entities,\n          relations: data.relations,\n          metadata: {\n            last_updated: new Date().toISOString(),\n            team,\n            entity_count: data.entities.length,\n            relation_count: data.relations.length\n          }\n        };\n\n        await fs.writeFile(filePath, JSON.stringify(json, null, 2));\n        return true;\n      } catch (error) {\n        attempts++;\n        if (attempts >= this.maxRetries) {\n          console.error(`Failed to export team ${team} after ${attempts} attempts:`, error);\n          return false;\n        }\n        await new Promise(resolve => setTimeout(resolve, delay));\n        delay *= 2; // Exponential backoff\n      }\n    }\n  }\n\n  startAutoSync() {\n    // Listen to graph events\n    this.graphDatabase.on('entity:stored', ({ team }) => {\n      this.queueExport(team);\n    });\n\n    this.graphDatabase.on('relationship:stored', ({ team }) => {\n      this.queueExport(team);\n    });\n  }\n}\n```\n\n### Component 4: KnowledgeStorageService (Updated)\n\n**Purpose**: High-level orchestration - unchanged external API, swaps SQLite → Graph internally\n\n**File Location**: `src/knowledge-management/KnowledgeStorageService.js` (existing, updated)\n\n**Changes**:\n```javascript\n// Before:\nclass KnowledgeStorageService {\n  constructor(config = {}) {\n    this.databaseManager = config.databaseManager; // SQLite + Qdrant\n  }\n\n  async storeKnowledge(knowledge, options = {}) {\n    // Validate\n    await this.validateKnowledge(knowledge);\n\n    // Store in SQLite\n    await this.databaseManager.storeKnowledgeExtraction(knowledge);\n\n    // Generate embeddings\n    const embedding = await this.generateEmbeddings(knowledge);\n\n    // Store in Qdrant\n    await this.databaseManager.storeVector(embedding, 'knowledge_patterns');\n  }\n}\n\n// After:\nclass KnowledgeStorageService {\n  constructor(config = {}) {\n    this.databaseManager = config.databaseManager; // Qdrant + SQLite (analytics)\n    this.graphDatabase = config.graphDatabase;     // NEW: Graph DB\n  }\n\n  async storeKnowledge(knowledge, options = {}) {\n    // Validate (unchanged)\n    await this.validateKnowledge(knowledge);\n\n    // Store in GRAPH (changed!)\n    await this.graphDatabase.storeEntity(knowledge, options);\n\n    // Generate embeddings (unchanged)\n    const embedding = await this.generateEmbeddings(knowledge);\n\n    // Store in Qdrant (unchanged)\n    await this.databaseManager.storeVector(embedding, 'knowledge_patterns');\n  }\n}\n```\n\n**Reuses**:\n- All existing validation logic\n- All existing embedding generation\n- All existing Qdrant integration\n- **Only swaps storage target**: SQLite → Graph\n\n## Data Models\n\n### Graph Node (Entity)\n\n```javascript\n{\n  // Node ID: \"{team}:{entityName}\" (e.g., \"coding:JWT Authentication\")\n  attributes: {\n    name: \"JWT Authentication\",           // Entity name\n    entityType: \"TechnicalPattern\",       // Pattern, Problem, Tool, etc.\n    observations: [                       // Array of observations\n      {\n        type: \"solution\",\n        content: \"Uses RS256 algorithm for signing\",\n        date: \"2025-10-21T10:00:00Z\",\n        context: \"session_abc123\"\n      }\n    ],\n    significance: 8,                      // 1-10 score\n    tags: [\"authentication\", \"security\"], // Searchable tags\n    team: \"coding\",                       // Team scope\n    confidence: 0.9,                      // Confidence score\n    createdAt: \"2025-10-21T10:00:00Z\",\n    lastModified: \"2025-10-21T10:30:00Z\"\n  }\n}\n```\n\n### Graph Edge (Relationship)\n\n```javascript\n{\n  // Edge connects two nodes by their IDs\n  source: \"coding:JWT Authentication\",\n  target: \"coding:Stateless Auth Problem\",\n  attributes: {\n    relationType: \"solves\",               // implements, solves, uses, related_to, etc.\n    confidence: 0.85,                     // Relationship confidence\n    team: \"coding\",                       // Team scope\n    metadata: {                           // Additional context\n      discoveredIn: \"session_abc123\",\n      reasoning: \"JWT provides stateless auth\"\n    },\n    createdAt: \"2025-10-21T10:15:00Z\"\n  }\n}\n```\n\n### JSON Export Format (Backward Compatible)\n\n```json\n{\n  \"entities\": [\n    {\n      \"name\": \"JWT Authentication\",\n      \"entityType\": \"TechnicalPattern\",\n      \"observations\": [\n        {\n          \"type\": \"solution\",\n          \"content\": \"Uses RS256 algorithm for signing\",\n          \"date\": \"2025-10-21T10:00:00Z\",\n          \"context\": \"session_abc123\"\n        }\n      ],\n      \"significance\": 8,\n      \"tags\": [\"authentication\", \"security\"]\n    }\n  ],\n  \"relations\": [\n    {\n      \"from\": \"JWT Authentication\",\n      \"to\": \"Stateless Auth Problem\",\n      \"type\": \"solves\",\n      \"confidence\": 0.85\n    }\n  ],\n  \"metadata\": {\n    \"last_updated\": \"2025-10-21T10:30:00Z\",\n    \"team\": \"coding\",\n    \"entity_count\": 47,\n    \"relation_count\": 123\n  }\n}\n```\n\n**Note**: This format is identical to current `shared-memory-*.json` format, ensuring VKB visualization works without changes.\n\n## Error Handling\n\n### Error Scenario 1: Level DB Unavailable\n\n**Description**: Level database fails to open or becomes corrupted\n\n**Handling**:\n```javascript\ntry {\n  this.levelDB = new Level(this.dbPath);\n  await this.levelDB.open();\n} catch (error) {\n  // Fall back to in-memory only mode\n  console.warn('Level DB unavailable, running in-memory only (data will not persist)');\n  this.inMemoryOnly = true;\n  // Continue operation with Graphology only\n  // Warn user that data won't persist across restarts\n}\n```\n\n**User Impact**: Data persists in session but not across restarts. Warning logged.\n\n### Error Scenario 2: Migration Verification Fails\n\n**Description**: Entity/relationship counts don't match after migration\n\n**Handling**:\n```javascript\nconst sqliteCount = await this.getSQLiteEntityCount();\nconst graphCount = this.graphDatabase.graph.order;\n\nif (sqliteCount !== graphCount) {\n  console.error(`Migration verification failed: SQLite has ${sqliteCount} entities, graph has ${graphCount}`);\n\n  // Automatic rollback\n  await this.rollback();\n\n  throw new Error('Migration failed verification, rolled back to SQLite');\n}\n```\n\n**User Impact**: Migration aborted, system restored to pre-migration state, error report generated.\n\n### Error Scenario 3: JSON Export Fails\n\n**Description**: File write fails (permissions, disk full, etc.)\n\n**Handling**:\n```javascript\nasync exportTeam(team) {\n  let attempts = 0;\n  while (attempts < this.maxRetries) {\n    try {\n      await fs.writeFile(filePath, json);\n      return true;\n    } catch (error) {\n      attempts++;\n      if (attempts >= this.maxRetries) {\n        // Log error, but don't crash the system\n        console.error(`Failed to export ${team} after ${attempts} attempts:`, error);\n        // Emit event for monitoring\n        this.emit('export:failed', { team, error });\n        return false;\n      }\n      await this._exponentialBackoff(attempts);\n    }\n  }\n}\n```\n\n**User Impact**: Export failure logged, system continues operation. Manual export command available as fallback.\n\n### Error Scenario 4: Concurrent Modification\n\n**Description**: Two processes try to modify the same entity simultaneously\n\n**Handling**:\n```javascript\nasync storeEntity(entity, options = {}) {\n  const nodeId = `${options.team}:${entity.name}`;\n\n  // Graphology is single-threaded (Node.js event loop)\n  // No race conditions within same process\n\n  // For multi-process: use file locking\n  if (options.lock) {\n    const release = await lock(this.dbPath);\n    try {\n      // ... perform operation\n    } finally {\n      await release();\n    }\n  }\n}\n```\n\n**User Impact**: Last write wins (Graphology in-memory). Multi-process requires explicit locking (not in scope for v1).\n\n### Error Scenario 5: Circular Dependency in Relationships\n\n**Description**: Relationship creation would create circular dependency\n\n**Handling**:\n```javascript\nasync storeRelationship(fromName, toName, relationType, metadata = {}) {\n  // Graphology allows cycles (real knowledge graphs have cycles!)\n  // Example: Pattern A implements Pattern B, Pattern B uses Pattern A\n\n  // No error - cycles are valid in knowledge graphs\n  // Traversal algorithms handle cycles (visited set prevents infinite loops)\n\n  this.graph.addEdge(fromId, toId, attributes);\n}\n```\n\n**User Impact**: None. Cycles are allowed and handled correctly in traversal.\n\n## Testing Strategy\n\n### Unit Testing\n\n**GraphDatabaseService Tests** (`tests/unit/GraphDatabaseService.test.js`):\n```javascript\ndescribe('GraphDatabaseService', () => {\n  describe('storeEntity', () => {\n    it('should create node with correct attributes', async () => {\n      const entity = {\n        name: 'Test Pattern',\n        entityType: 'TechnicalPattern',\n        observations: ['obs1']\n      };\n\n      const nodeId = await graphDB.storeEntity(entity, { team: 'test' });\n\n      expect(nodeId).toBe('test:Test Pattern');\n      expect(graphDB.graph.hasNode(nodeId)).toBe(true);\n      expect(graphDB.graph.getNodeAttribute(nodeId, 'entityType')).toBe('TechnicalPattern');\n    });\n\n    it('should emit entity:stored event', async () => {\n      const spy = jest.fn();\n      graphDB.on('entity:stored', spy);\n\n      await graphDB.storeEntity(entity, { team: 'test' });\n\n      expect(spy).toHaveBeenCalledWith(expect.objectContaining({ team: 'test' }));\n    });\n  });\n\n  describe('findRelated', () => {\n    it('should traverse 2 hops correctly', async () => {\n      // Setup: A -> B -> C\n      await graphDB.storeEntity({ name: 'A' }, { team: 'test' });\n      await graphDB.storeEntity({ name: 'B' }, { team: 'test' });\n      await graphDB.storeEntity({ name: 'C' }, { team: 'test' });\n      await graphDB.storeRelationship('A', 'B', 'implements', { team: 'test' });\n      await graphDB.storeRelationship('B', 'C', 'uses', { team: 'test' });\n\n      const related = await graphDB.findRelated('A', 2, { team: 'test' });\n\n      expect(related).toHaveLength(2);\n      expect(related.some(r => r.entity.name === 'B' && r.depth === 1)).toBe(true);\n      expect(related.some(r => r.entity.name === 'C' && r.depth === 2)).toBe(true);\n    });\n  });\n});\n```\n\n**GraphExportService Tests** (`tests/unit/GraphExportService.test.js`):\n```javascript\ndescribe('GraphExportService', () => {\n  describe('batching', () => {\n    it('should batch multiple exports within 5 seconds', async () => {\n      jest.useFakeTimers();\n      const writeSpy = jest.spyOn(fs, 'writeFile');\n\n      exportService.queueExport('test');\n      exportService.queueExport('test');\n      exportService.queueExport('test');\n\n      // Should not have written yet\n      expect(writeSpy).not.toHaveBeenCalled();\n\n      // Advance 5 seconds\n      jest.advanceTimersByTime(5000);\n      await Promise.resolve(); // Wait for promises\n\n      // Should have written once\n      expect(writeSpy).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('retry logic', () => {\n    it('should retry 3 times on failure', async () => {\n      jest.spyOn(fs, 'writeFile').mockRejectedValue(new Error('Disk full'));\n\n      const result = await exportService.exportTeam('test');\n\n      expect(result).toBe(false);\n      expect(fs.writeFile).toHaveBeenCalledTimes(3);\n    });\n  });\n});\n```\n\n### Integration Testing\n\n**End-to-End Migration Test** (`tests/integration/migration.test.js`):\n```javascript\ndescribe('Migration Integration', () => {\n  it('should migrate all data from SQLite to graph', async () => {\n    // Setup: Populate SQLite with test data\n    await databaseManager.storeKnowledgeExtraction({\n      entity_name: 'Test Pattern',\n      entity_type: 'Pattern',\n      observations: JSON.stringify(['obs1', 'obs2']),\n      team: 'test'\n    });\n\n    // Run migration\n    const report = await migrationService.runMigration();\n\n    // Verify\n    expect(report.success).toBe(true);\n    expect(report.entitiesMigrated).toBe(1);\n\n    // Verify in graph\n    const entity = await graphDB.getEntity('Test Pattern', 'test');\n    expect(entity).toBeTruthy();\n    expect(entity.observations).toEqual(['obs1', 'obs2']);\n  });\n\n  it('should rollback on verification failure', async () => {\n    // Simulate verification failure\n    jest.spyOn(migrationService, 'verifyMigration').mockResolvedValue({\n      success: false,\n      reason: 'Count mismatch'\n    });\n\n    await expect(migrationService.runMigration()).rejects.toThrow('Migration failed');\n\n    // Verify SQLite still has data\n    const sqliteData = await databaseManager.getAllKnowledge();\n    expect(sqliteData.length).toBeGreaterThan(0);\n  });\n});\n```\n\n**Auto-Sync Integration Test** (`tests/integration/auto-sync.test.js`):\n```javascript\ndescribe('Auto-Sync Integration', () => {\n  it('should auto-sync to JSON after entity storage', async () => {\n    jest.useFakeTimers();\n\n    // Start auto-sync\n    exportService.startAutoSync();\n\n    // Store entity\n    await graphDB.storeEntity({ name: 'Test' }, { team: 'test' });\n\n    // Advance timers\n    jest.advanceTimersByTime(5000);\n    await Promise.resolve();\n\n    // Verify JSON file exists and contains entity\n    const json = JSON.parse(await fs.readFile('shared-memory-test.json', 'utf8'));\n    expect(json.entities.some(e => e.name === 'Test')).toBe(true);\n  });\n});\n```\n\n### End-to-End Testing\n\n**VKB Visualization Test** (`tests/e2e/vkb.test.js`):\n```javascript\ndescribe('VKB with Graph Database', () => {\n  it('should load and visualize graph data', async () => {\n    // Store entities and relationships\n    await graphDB.storeEntity({ name: 'Pattern A' }, { team: 'test' });\n    await graphDB.storeEntity({ name: 'Pattern B' }, { team: 'test' });\n    await graphDB.storeRelationship('Pattern A', 'Pattern B', 'implements', { team: 'test' });\n\n    // Trigger export\n    await exportService.exportTeam('test');\n\n    // Launch VKB server\n    const vkb = spawn('npm', ['run', 'vkb']);\n    await waitForServer('http://localhost:8080');\n\n    // Fetch data via VKB API\n    const response = await fetch('http://localhost:8080/api/knowledge');\n    const data = await response.json();\n\n    // Verify\n    expect(data.entities).toHaveLength(2);\n    expect(data.relations).toHaveLength(1);\n  });\n});\n```\n\n**Performance Benchmark Test** (`tests/performance/graph-queries.test.js`):\n```javascript\ndescribe('Graph Query Performance', () => {\n  beforeAll(async () => {\n    // Populate with 1000 entities, 5000 relationships\n    await populateTestData(1000, 5000);\n  });\n\n  it('should find 2-hop relationships in <50ms', async () => {\n    const start = Date.now();\n\n    const related = await graphDB.findRelated('Test Entity 500', 2);\n\n    const duration = Date.now() - start;\n    expect(duration).toBeLessThan(50);\n  });\n\n  it('should find 3-hop relationships in <100ms', async () => {\n    const start = Date.now();\n\n    const related = await graphDB.findRelated('Test Entity 500', 3);\n\n    const duration = Date.now() - start;\n    expect(duration).toBeLessThan(100);\n  });\n});\n```\n\n## Configuration\n\n### Graph Database Configuration\n\n**File**: `config/graph-database-config.json`\n\n```json\n{\n  \"database\": {\n    \"type\": \"graphology-level\",\n    \"path\": \".data/knowledge-graph\",\n    \"options\": {\n      \"multi\": true,\n      \"valueEncoding\": \"json\"\n    }\n  },\n  \"persistence\": {\n    \"autoPersist\": true,\n    \"persistIntervalMs\": 1000,\n    \"batchSize\": 100\n  },\n  \"export\": {\n    \"enabled\": true,\n    \"batchWindowMs\": 5000,\n    \"maxRetries\": 3,\n    \"retryDelayMs\": 1000,\n    \"outputDir\": \".\",\n    \"filePattern\": \"shared-memory-{team}.json\"\n  },\n  \"performance\": {\n    \"maxTraversalDepth\": 5,\n    \"maxResultsPerQuery\": 1000\n  }\n}\n```\n\n### Environment Variables\n\n```bash\n# Graph database path\nGRAPH_DB_PATH=.data/knowledge-graph\n\n# Team scope\nCODING_TEAM=coding\n\n# Auto-sync configuration\nGRAPH_AUTO_SYNC=true\nGRAPH_SYNC_BATCH_WINDOW_MS=5000\n\n# Performance tuning\nGRAPH_MAX_TRAVERSAL_DEPTH=5\nGRAPH_MAX_RESULTS=1000\n```\n\n## Migration Plan\n\n### Pre-Migration Checklist\n\n- [ ] Backup current SQLite database\n- [ ] Verify Graphology and Level are installed\n- [ ] Ensure sufficient disk space (estimate 2x current SQLite size)\n- [ ] Stop all services using knowledge database\n- [ ] Verify no pending writes to SQLite\n\n### Migration Steps\n\n1. **Run migration script**:\n   ```bash\n   node scripts/knowledge-management/migrate-to-graph.js\n   ```\n\n2. **Monitor progress**:\n   - Real-time progress reporting\n   - Estimated time based on entity count\n   - Verification checkpoints\n\n3. **Verify success**:\n   - Check migration report\n   - Verify entity/relationship counts\n   - Sample random entities for integrity\n   - Test VKB visualization\n\n4. **Update service configuration**:\n   - Remove MCP Memory from `claude-code-mcp.json`\n   - Update `DatabaseManager` initialization\n   - Update `KnowledgeStorageService` to use graph\n\n5. **Restart services**:\n   ```bash\n   bin/coding restart\n   ```\n\n### Rollback Procedure\n\nIf migration fails or issues are discovered:\n\n```bash\nnode scripts/knowledge-management/rollback-migration.js\n```\n\nThis will:\n1. Stop graph database service\n2. Restore SQLite from backup\n3. Remove graph database files\n4. Restore original configuration\n5. Restart services with SQLite\n\n## Performance Optimization\n\n### Index Strategy\n\nGraphology provides O(1) access by node ID:\n- Node ID format: `{team}:{entityName}` enables team filtering\n- Multi-graph allows multiple edges between same nodes\n- Neighbor queries are O(degree) - very fast for typical knowledge graphs\n\n### Caching Strategy\n\n```javascript\nclass GraphDatabaseService {\n  constructor() {\n    // LRU cache for frequently accessed entities\n    this.entityCache = new LRU({ max: 1000 });\n  }\n\n  async getEntity(name, team) {\n    const cacheKey = `${team}:${name}`;\n\n    if (this.entityCache.has(cacheKey)) {\n      return this.entityCache.get(cacheKey);\n    }\n\n    const entity = this.graph.getNodeAttributes(cacheKey);\n    this.entityCache.set(cacheKey, entity);\n\n    return entity;\n  }\n}\n```\n\n### Memory Management\n\n- Level persistence keeps memory footprint reasonable\n- Periodic flush to disk (every 1 second)\n- Large graphs (>10K nodes) may need streaming queries\n\n### Query Optimization\n\n```javascript\n// Optimized 2-hop query\nasync findPatternsSolvingSimilarProblems(patternName, team) {\n  // Pre-filter by team at node ID level (faster than attribute filtering)\n  const startNode = `${team}:${patternName}`;\n\n  // Use BFS with early termination\n  const neighbors = this.graph.neighbors(startNode);\n  const problems = neighbors.filter(n =>\n    this.graph.getNodeAttribute(n, 'entityType') === 'Problem'\n  );\n\n  const similarPatterns = [];\n  for (const problem of problems) {\n    const solvers = this.graph.inNeighbors(problem);\n    similarPatterns.push(...solvers.filter(s => s !== startNode));\n  }\n\n  return similarPatterns;\n}\n```\n\n## Deployment Considerations\n\n### Installation\n\n```bash\n# Level is already in package.json\nnpm install\n\n# Initialize graph database\nnode scripts/init-graph-database.js\n```\n\n### Service Startup\n\n```bash\n# Start all services (including graph DB)\nbin/coding start\n\n# Check health\nbin/coding status\n```\n\n### Monitoring\n\nHealth check endpoint:\n```javascript\nasync getHealth() {\n  return {\n    graphDB: {\n      status: this.initialized ? 'healthy' : 'down',\n      nodeCount: this.graph.order,\n      edgeCount: this.graph.size,\n      levelDB: await this.levelDB.status(),\n      lastPersist: this.lastPersistTime\n    }\n  };\n}\n```\n\n### Backup Strategy\n\nAutomated backups:\n```bash\n# Daily backup of graph database\n0 2 * * * /usr/bin/tar -czf /backups/graph-$(date +\\%Y\\%m\\%d).tar.gz .data/knowledge-graph\n```\n\n## Security Considerations\n\n### File Permissions\n\n```bash\n# Graph database files (read/write for owner only)\nchmod 600 .data/knowledge-graph/*\n\n# JSON exports (read for group)\nchmod 640 shared-memory-*.json\n```\n\n### Team Isolation\n\n```javascript\n// Enforce team boundaries at query level\nasync getEntity(name, team) {\n  const nodeId = `${team}:${name}`;\n\n  // Team prefix in ID ensures no cross-team access\n  if (!this.graph.hasNode(nodeId)) {\n    return null;\n  }\n\n  return this.graph.getNodeAttributes(nodeId);\n}\n```\n\n### Secret Redaction\n\nMaintained in JSON export:\n```javascript\nasync exportTeam(team) {\n  const entities = await this.graphDatabase.exportTeam(team);\n\n  // Apply same redaction as existing system\n  const redacted = await secretRedactor.redactEntities(entities);\n\n  await fs.writeFile(filePath, JSON.stringify(redacted, null, 2));\n}\n```\n\n---\n\n**Design Status**: ✅ Ready for Review\n**Next Phase**: Tasks Document (after approval)\n**Estimated Implementation**: 12-16 hours\n**Risk Level**: Low (proven technologies, comprehensive testing)\n",
  "fileStats": {
    "size": 40422,
    "lines": 1470,
    "lastModified": "2025-10-21T09:04:40.508Z"
  },
  "comments": []
}