#!/usr/bin/env node
/**
 * PlantUML PNG Error Detector
 *
 * Detects if a PNG generated by PlantUML contains an error output
 * (black background with green text) rather than a valid diagram.
 *
 * Error images have a distinctive signature:
 * - Predominantly black background (#000000)
 * - Bright green text (#00FF00 or similar)
 * - Very limited color palette (mostly just black and green)
 *
 * Valid diagrams typically have:
 * - White or light backgrounds
 * - Multiple colors for components, arrows, etc.
 * - Broader color distribution
 *
 * Usage:
 *   node validate-plantuml-png.js <png-file> [--verbose]
 *   node validate-plantuml-png.js --batch <directory> [--verbose]
 *
 * Exit codes:
 *   0 - Valid diagram(s)
 *   1 - Error diagram detected
 *   2 - File/argument error
 */

import fs from 'fs';
import path from 'path';
import sharp from 'sharp';

// Color thresholds for error detection
const ERROR_DETECTION = {
  // Black background detection (RGB values close to 0)
  BLACK_THRESHOLD: 30,
  // Green text detection (high G, low R and B)
  GREEN_MIN_G: 200,
  GREEN_MAX_R: 100,
  GREEN_MAX_B: 100,
  // Percentage thresholds
  MIN_BLACK_PERCENTAGE: 40,  // Error images are mostly black
  MIN_GREEN_PERCENTAGE: 5,   // Must have some green text
  MAX_COLOR_VARIETY: 50,     // Error images have few unique colors
};

/**
 * Analyze a PNG file for PlantUML error signature
 */
async function analyzePng(filePath, verbose = false) {
  if (!fs.existsSync(filePath)) {
    throw new Error(`File not found: ${filePath}`);
  }

  const image = sharp(filePath);
  const metadata = await image.metadata();
  const { width, height } = metadata;

  // Get raw pixel data
  const { data } = await image.raw().toBuffer({ resolveWithObject: true });

  const totalPixels = width * height;
  let blackPixels = 0;
  let greenPixels = 0;
  let whitePixels = 0;
  const uniqueColors = new Set();

  // Iterate through pixels (3 channels: R, G, B)
  for (let i = 0; i < data.length; i += 3) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];

    // Track unique colors (quantize to reduce noise)
    const quantizedColor = `${Math.floor(r/16)}-${Math.floor(g/16)}-${Math.floor(b/16)}`;
    uniqueColors.add(quantizedColor);

    // Check for black
    if (r <= ERROR_DETECTION.BLACK_THRESHOLD &&
        g <= ERROR_DETECTION.BLACK_THRESHOLD &&
        b <= ERROR_DETECTION.BLACK_THRESHOLD) {
      blackPixels++;
    }

    // Check for bright green (PlantUML error text color)
    if (g >= ERROR_DETECTION.GREEN_MIN_G &&
        r <= ERROR_DETECTION.GREEN_MAX_R &&
        b <= ERROR_DETECTION.GREEN_MAX_B) {
      greenPixels++;
    }

    // Check for white/light background (valid diagrams)
    if (r >= 240 && g >= 240 && b >= 240) {
      whitePixels++;
    }
  }

  const blackPercentage = (blackPixels / totalPixels) * 100;
  const greenPercentage = (greenPixels / totalPixels) * 100;
  const whitePercentage = (whitePixels / totalPixels) * 100;
  const colorVariety = uniqueColors.size;

  const analysis = {
    filePath,
    dimensions: { width, height },
    totalPixels,
    blackPixels,
    greenPixels,
    whitePixels,
    blackPercentage: blackPercentage.toFixed(2),
    greenPercentage: greenPercentage.toFixed(2),
    whitePercentage: whitePercentage.toFixed(2),
    colorVariety,
    isError: false,
    errorReasons: [],
  };

  // Determine if this is an error image
  if (blackPercentage >= ERROR_DETECTION.MIN_BLACK_PERCENTAGE) {
    analysis.errorReasons.push(`High black content: ${blackPercentage.toFixed(1)}%`);
  }

  if (greenPercentage >= ERROR_DETECTION.MIN_GREEN_PERCENTAGE) {
    analysis.errorReasons.push(`Contains green text: ${greenPercentage.toFixed(1)}%`);
  }

  if (colorVariety <= ERROR_DETECTION.MAX_COLOR_VARIETY && blackPercentage > 30) {
    analysis.errorReasons.push(`Low color variety: ${colorVariety} unique colors`);
  }

  // Final determination: error if high black AND has green text
  analysis.isError = blackPercentage >= ERROR_DETECTION.MIN_BLACK_PERCENTAGE &&
                     greenPercentage >= ERROR_DETECTION.MIN_GREEN_PERCENTAGE;

  if (verbose) {
    console.log('\n--- Analysis Results ---');
    console.log(`File: ${filePath}`);
    console.log(`Dimensions: ${width}x${height}`);
    console.log(`Black pixels: ${blackPercentage.toFixed(2)}%`);
    console.log(`Green pixels: ${greenPercentage.toFixed(2)}%`);
    console.log(`White pixels: ${whitePercentage.toFixed(2)}%`);
    console.log(`Color variety: ${colorVariety} unique colors`);
    console.log(`Is Error: ${analysis.isError}`);
    if (analysis.errorReasons.length > 0) {
      console.log(`Reasons: ${analysis.errorReasons.join('; ')}`);
    }
  }

  return analysis;
}

/**
 * Validate a single PNG file
 */
async function validateFile(filePath, verbose = false) {
  try {
    const analysis = await analyzePng(filePath, verbose);

    if (analysis.isError) {
      console.error(`❌ ERROR: ${filePath}`);
      console.error(`   PlantUML error image detected: ${analysis.errorReasons.join('; ')}`);
      return false;
    } else {
      if (verbose) {
        console.log(`✅ VALID: ${filePath}`);
      }
      return true;
    }
  } catch (err) {
    console.error(`⚠️  FAILED: ${filePath} - ${err.message}`);
    return false;
  }
}

/**
 * Validate all PNG files in a directory
 */
async function validateDirectory(dirPath, verbose = false) {
  if (!fs.existsSync(dirPath)) {
    console.error(`Directory not found: ${dirPath}`);
    return false;
  }

  const files = fs.readdirSync(dirPath)
    .filter(f => f.endsWith('.png'))
    .map(f => path.join(dirPath, f));

  if (files.length === 0) {
    console.log(`No PNG files found in ${dirPath}`);
    return true;
  }

  console.log(`Validating ${files.length} PNG files in ${dirPath}...`);

  let allValid = true;
  let errorCount = 0;

  for (const file of files) {
    const valid = await validateFile(file, verbose);
    if (!valid) {
      allValid = false;
      errorCount++;
    }
  }

  console.log(`\nResults: ${files.length - errorCount}/${files.length} valid`);

  return allValid;
}

/**
 * Main entry point
 */
async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.log('Usage:');
    console.log('  node validate-plantuml-png.js <png-file> [--verbose]');
    console.log('  node validate-plantuml-png.js --batch <directory> [--verbose]');
    process.exit(2);
  }

  const verbose = args.includes('--verbose') || args.includes('-v');
  const batchIndex = args.indexOf('--batch');

  if (batchIndex !== -1) {
    const dirPath = args[batchIndex + 1];
    if (!dirPath) {
      console.error('Error: --batch requires a directory path');
      process.exit(2);
    }
    const success = await validateDirectory(dirPath, verbose);
    process.exit(success ? 0 : 1);
  } else {
    const filePath = args.find(a => !a.startsWith('-'));
    if (!filePath) {
      console.error('Error: No file path provided');
      process.exit(2);
    }
    const success = await validateFile(filePath, verbose);
    process.exit(success ? 0 : 1);
  }
}

// Export for use as module
export { analyzePng, validateFile, validateDirectory };

// Run if called directly
main().catch(err => {
  console.error('Fatal error:', err.message);
  process.exit(2);
});
