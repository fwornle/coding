---
phase: 01-core-pipeline-data-quality
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - integrations/mcp-server-semantic-analysis/src/agents/insight-generation-agent.ts
autonomous: true
requirements:
  - PTRN-01
  - PTRN-02
  - PTRN-03
  - NAME-01

must_haves:
  truths:
    - "parseArchitecturalPatternsFromLLM() extracts patterns from numbered-bold-markdown format (1. **PatternName**: description)"
    - "parseArchitecturalPatternsFromLLM() extracts patterns from section-header format (### 1. PatternName)"
    - "parseArchitecturalPatternsFromLLM() extracts patterns from JSON-formatted LLM responses"
    - "parseArchitecturalPatternsFromLLM() preserves original Pattern: labeled format as fallback"
    - "formatPatternName() preserves existing PascalCase sub-words (PathAnalyzer stays PathAnalyzer, not Pathanalyzer)"
    - "Extracted patterns have LLM-assigned significance scores when provided"
    - "On zero extraction after all parse strategies, LLM is retried once with explicit format hints in the prompt"
  artifacts:
    - path: "integrations/mcp-server-semantic-analysis/src/agents/insight-generation-agent.ts"
      provides: "Multi-format pattern parser and correct PascalCase formatter"
      contains: "parseArchitecturalPatternsFromLLM"
  key_links:
    - from: "parseArchitecturalPatternsFromLLM()"
      to: "finalizePattern()"
      via: "Each successfully parsed pattern is finalized with commit evidence"
      pattern: "this\\.finalizePattern"
    - from: "formatPatternName()"
      to: "pattern.name field"
      via: "Every extracted pattern name goes through formatPatternName before storage"
      pattern: "this\\.formatPatternName"
    - from: "parseArchitecturalPatternsFromLLM() zero-result branch"
      to: "this.semanticAnalyzer.analyzeContent()"
      via: "Single LLM retry with format-hint prompt when all parse strategies yield zero patterns"
      pattern: "semanticAnalyzer\\.analyzeContent"
---

<objective>
Fix the pattern extraction parser and pattern name formatter in the insight generation agent so the pipeline actually extracts patterns from LLM responses.

Purpose: The LLM returns patterns in markdown-formatted responses (numbered lists with bold markers, section headers, or JSON), but the current parser only matches `Pattern:` / `Architecture:` / `Design:` prefixed lines -- a format the LLM never uses. This causes zero pattern extraction on every run. Additionally, `formatPatternName()` destroys existing PascalCase by applying `.toLowerCase()` to word suffixes.

Output: A working multi-format parser that handles all observed LLM output formats, and a PascalCase formatter that preserves existing capitalization boundaries.
</objective>

<execution_context>
@/Users/Q284340/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Q284340/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-pipeline-data-quality/01-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs -->

From integrations/mcp-server-semantic-analysis/src/agents/insight-generation-agent.ts:
```typescript
export interface IdentifiedPattern {
  name: string;
  category: string;
  description: string;
  significance: number;
  evidence: string[];
  relatedComponents: string[];
  implementation: {
    language: string;
    codeExample?: string;
    usageNotes: string[];
  };
}
```

Current `parseArchitecturalPatternsFromLLM()` signature (line 4755):
```typescript
private async parseArchitecturalPatternsFromLLM(
  llmInsights: string,
  commits: any[]
): Promise<IdentifiedPattern[]>
```

Current `formatPatternName()` (line 4829):
```typescript
private formatPatternName(rawName: string): string
```

Current `finalizePattern()` (line 4839):
```typescript
private finalizePattern(partial: Partial<IdentifiedPattern>, commits: any[]): IdentifiedPattern
```

Helper `log()` is available as a module-level function: `log(message: string, level: string, data?: any)`
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace parseArchitecturalPatternsFromLLM with multi-format parser</name>
  <files>integrations/mcp-server-semantic-analysis/src/agents/insight-generation-agent.ts</files>
  <action>
Replace the body of `parseArchitecturalPatternsFromLLM()` (lines 4755-4827) with a multi-strategy parser that tries formats in reliability order:

**Strategy 1 -- JSON parse (most reliable):**
- Strip markdown code fences: `llmInsights.replace(/^```json?\n?/m, '').replace(/\n?```$/m, '').trim()`
- Attempt `JSON.parse()` on the cleaned string
- Accept both `{ patterns: [...] }` wrapper and top-level array `[...]`
- For each item, extract: `name` (or `pattern`), `description`, `significance` (default 7), `category`
- Map through `this.formatPatternName()` and `this.finalizePattern()`
- If array is non-empty, return immediately (skip line-based parsing)
- Wrap in try/catch -- if JSON fails, fall through to Strategy 2

**Strategy 2 -- Line-based multi-format parsing:**
Iterate over lines. For each trimmed line, try these regex matches IN ORDER:

a) **Numbered bold markdown**: `/^\d+\.\s+\*\*(.+?)\*\*[:\s]*(.*)/`
   - Capture group 1 = pattern name, group 2 = start of description
   - This is the most common format from Groq/Claude

b) **Section headers**: `/^#{1,3}\s+(?:\d+\.\s+)?([A-Z][A-Za-z]+(?:[A-Z][A-Za-z]*)*)/`
   - Capture group 1 = pattern name
   - IMPORTANT: Skip generic section titles. Add exclusion set: `['PatternIdentification', 'PatternDescriptions', 'ArchitecturalPatterns', 'DesignPatterns', 'IdentifiedPatterns', 'Summary', 'Analysis', 'Overview', 'Conclusion', 'Introduction']`
   - Only treat as pattern name if NOT in exclusion set

c) **Original labeled format** (existing): `/^(Pattern|Architecture|Design):\s*(.+)/i`
   - Keep as final fallback

For ALL three formats: when a new pattern header is found, finalize any `currentPattern` via `this.finalizePattern()`, then create a new `currentPattern` object. Use destructured match results (NOT `RegExp.$1`/`RegExp.$2`).

**Description/significance/evidence collection** (within a currentPattern):
- Description line: `/^(Description|Purpose|Summary):\s*(.+)/i` -- use `match[2]`
- Significance line: `/^(Significance|Importance|Impact):\s*(\d+)/i` -- `Math.min(10, Math.max(1, parseInt(match[2])))`
- Implementation line: `/^(Implementation|Code|Example):/i` -- push to usageNotes
- Any other line with length > 20 -- push to evidence array

After loop: finalize last `currentPattern` if it has a name.

**Strategy 3 -- LLM retry with format hints (per user decision: "On parse failure: retry with explicit format hints in the prompt"):**
If patterns.length === 0 after Strategy 1 and Strategy 2, perform a single LLM retry:

```typescript
if (patterns.length === 0) {
  log('Zero patterns extracted from initial response, retrying with format hints', 'warning', {
    responseLength: llmInsights.length,
    commitCount: commits.length
  });

  try {
    const formatHintPrompt = `The following analysis text could not be parsed into structured patterns. Please re-analyze and respond STRICTLY in this JSON format:

\`\`\`json
[
  {
    "name": "PatternNameInPascalCase",
    "description": "What this pattern does and why it matters",
    "significance": 7,
    "category": "architecture"
  }
]
\`\`\`

Original analysis to re-format:
${llmInsights.substring(0, 3000)}`;

    const retryResult = await this.semanticAnalyzer.analyzeContent(formatHintPrompt, {
      analysisType: 'patterns',
      provider: 'auto',
      taskType: 'pattern_extraction_retry'
    });

    // Parse retry result using same Strategy 1 (JSON) logic
    const retryCleaned = retryResult.insights
      .replace(/^```json?\n?/m, '').replace(/\n?```$/m, '').trim();
    const retryParsed = JSON.parse(retryCleaned);
    const retryArray = Array.isArray(retryParsed) ? retryParsed : (retryParsed.patterns || []);

    for (const item of retryArray) {
      const name = this.formatPatternName(item.name || item.pattern || 'Unknown');
      patterns.push(this.finalizePattern({
        name,
        description: item.description || '',
        significance: item.significance || 7,
        category: item.category || 'architecture',
        evidence: [],
        relatedComponents: [],
        implementation: { language: 'typescript', usageNotes: [] }
      }, commits));
    }

    if (patterns.length > 0) {
      log(`Retry with format hints succeeded: extracted ${patterns.length} patterns`, 'info');
    }
  } catch (retryError) {
    log('LLM retry with format hints also failed', 'warning', {
      error: retryError instanceof Error ? retryError.message : String(retryError)
    });
  }
}
```

**Logging:** If patterns.length is still 0 after all strategies including retry, log warning with `llmInsights.length` and `commits.length`. If patterns found, log info with count: `Extracted ${patterns.length} patterns from LLM response`.

**Error handling:** Entire function body wrapped in try/catch. On error, log error and return empty array. Never throw.
  </action>
  <verify>
    <automated>grep -c "boldMatch\|headerMatch\|JSON\.parse\|pattern_extraction_retry" integrations/mcp-server-semantic-analysis/src/agents/insight-generation-agent.ts | xargs test 4 -le</automated>
  </verify>
  <done>
    - parseArchitecturalPatternsFromLLM handles JSON, numbered-bold-markdown, section-header, and labeled formats
    - Uses destructured match objects, not RegExp.$N globals
    - Generic section titles are excluded from header pattern matching
    - On zero extraction, retries LLM once with explicit JSON format hints in the prompt
    - Logs pattern count on success, logs warning with context on zero extraction (including after retry)
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix formatPatternName PascalCase preservation</name>
  <files>integrations/mcp-server-semantic-analysis/src/agents/insight-generation-agent.ts</files>
  <action>
Replace the body of `formatPatternName()` (lines 4829-4837) to correctly preserve existing PascalCase sub-words.

**Current buggy code:**
```typescript
const words = rawName.replace(/[^a-zA-Z0-9\s]/g, '').split(/\s+/);
const pascalCase = words
  .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
  .join('');
```

**Fixed code:**
```typescript
private formatPatternName(rawName: string): string {
  // Strip non-alphanumeric except spaces, split on camelCase boundaries
  const words = rawName
    .replace(/[^a-zA-Z0-9\s]/g, '')
    .replace(/([a-z])([A-Z])/g, '$1 $2')  // Split camelCase: "pathAnalyzer" -> "path Analyzer"
    .split(/\s+/)
    .filter(w => w.length > 0);

  const pascalCase = words
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))  // Preserve existing case after first char
    .join('');

  return pascalCase.endsWith('Pattern') ? pascalCase : pascalCase + 'Pattern';
}
```

Key changes:
1. Add `.replace(/([a-z])([A-Z])/g, '$1 $2')` BEFORE split -- breaks camelCase words into separate tokens
2. Remove `.toLowerCase()` from `word.slice(1)` -- preserves existing capitalization in sub-words
3. Add `.filter(w => w.length > 0)` to handle multiple consecutive spaces

This ensures:
- `"KnowledgeGraphPersistence"` -> splits to `["Knowledge", "Graph", "Persistence"]` -> `"KnowledgeGraphPersistencePattern"`
- `"pathAnalyzer"` -> splits to `["path", "Analyzer"]` -> `"PathAnalyzerPattern"`
- `"MVI Redux Architecture"` -> splits to `["MVI", "Redux", "Architecture"]` -> `"MVIReduxArchitecturePattern"`
  </action>
  <verify>
    <automated>cd /Users/Q284340/Agentic/coding && grep -A15 "formatPatternName" integrations/mcp-server-semantic-analysis/src/agents/insight-generation-agent.ts | grep "slice(1)" | grep -v "toLowerCase()" | grep -q "slice(1)" && echo "PASS: No toLowerCase on slice(1)"</automated>
  </verify>
  <done>
    - formatPatternName splits on camelCase boundaries before case transformation
    - Existing PascalCase sub-words are preserved (no .toLowerCase() on word suffixes)
    - "PathAnalyzer" produces "PathAnalyzerPattern", not "PathanalyzerPattern"
    - "KnowledgeGraphPersistence" produces "KnowledgeGraphPersistencePattern"
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify end-to-end:

1. **TypeScript compilation**: `cd integrations/mcp-server-semantic-analysis && npx tsc --noEmit` -- must pass with no errors in insight-generation-agent.ts
2. **Multi-format parser coverage**: grep for all four strategy branches (JSON.parse, bold match regex, header match regex, original labeled regex) plus the LLM retry branch (semanticAnalyzer.analyzeContent with format hints)
3. **No RegExp.$N usage**: `grep -n 'RegExp\.\$' src/agents/insight-generation-agent.ts` should return zero matches in the parseArchitecturalPatternsFromLLM function
4. **PascalCase fix applied**: `formatPatternName` must NOT contain `.toLowerCase()` call on `word.slice(1)`
</verification>

<success_criteria>
- parseArchitecturalPatternsFromLLM handles JSON, numbered-bold-markdown, section-header, and original labeled formats, with LLM retry on zero extraction
- formatPatternName preserves existing PascalCase in sub-words
- No use of fragile RegExp.$N global state
- TypeScript compiles without errors
- All changes in insight-generation-agent.ts only
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-pipeline-data-quality/01-01-SUMMARY.md`
</output>
