---
phase: 01-core-pipeline-data-quality
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - integrations/mcp-server-semantic-analysis/src/agents/observation-generation-agent.ts
  - integrations/mcp-server-semantic-analysis/src/agents/coordinator.ts
autonomous: true
requirements:
  - NAME-01
  - NAME-02
  - OBSV-01
  - OBSV-02
  - DATA-03

must_haves:
  truths:
    - "toPascalCase() preserves existing PascalCase sub-words (PathAnalyzer stays PathAnalyzer, not Pathanalyzer)"
    - "generateCleanEntityName() preserves existing PascalCase in individual words"
    - "createArchitecturalDecisionObservation() calls LLM for observation synthesis instead of using template strings"
    - "createCodeEvolutionObservation() calls LLM for observation synthesis instead of using template strings"
    - "LLM synthesis failures fall back gracefully to basic content without crashing"
    - "coordinator.ts passes analysisDepth 'deep' instead of 'surface'"
    - "End-of-observation-generation summary logs entity count and error count"
  artifacts:
    - path: "integrations/mcp-server-semantic-analysis/src/agents/observation-generation-agent.ts"
      provides: "PascalCase-preserving naming and LLM-synthesized observations"
      contains: "createArchitecturalDecisionObservation"
    - path: "integrations/mcp-server-semantic-analysis/src/agents/coordinator.ts"
      provides: "Deep analysis depth configuration"
      contains: "analysisDepth"
  key_links:
    - from: "createArchitecturalDecisionObservation()"
      to: "this.semanticAnalyzer.analyzeContent()"
      via: "LLM synthesis call for architectural decision observations"
      pattern: "semanticAnalyzer\\.analyzeContent"
    - from: "createCodeEvolutionObservation()"
      to: "this.semanticAnalyzer.analyzeContent()"
      via: "LLM synthesis call for code evolution observations"
      pattern: "semanticAnalyzer\\.analyzeContent"
    - from: "coordinator.ts analyzeGitAndVibeData call"
      to: "semantic-analysis-agent.ts"
      via: "analysisDepth option flows from coordinator to semantic agent"
      pattern: "analysisDepth.*deep"
---

<objective>
Fix entity naming (PascalCase preservation), replace template-string observations with LLM-synthesized content, and switch analysis depth from 'surface' to 'deep'.

Purpose: Entity names are mangled ("Pathanalyzerpattern" instead of "PathAnalyzerPattern") because `toPascalCase()` and `generateCleanEntityName()` destroy existing capitalization. Observations are useless template strings ("When working with X in this codebase...") instead of LLM-synthesized analysis. Analysis depth is locked to 'surface', preventing the LLM from seeing full file contents.

Output: Correctly-named entities with meaningful LLM-synthesized observations, running at deep analysis depth.
</objective>

<execution_context>
@/Users/Q284340/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Q284340/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-pipeline-data-quality/01-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs -->

From integrations/mcp-server-semantic-analysis/src/agents/observation-generation-agent.ts:
```typescript
export interface StructuredObservation {
  name: string;
  entityType: string;
  significance: number;
  observations: (string | ObservationTemplate)[];
  tags?: string[];
  relationships: {
    from: string;
    to: string;
    relationType: string;
    type?: string;
    target?: string;
    description?: string;
  }[];
  metadata: {
    created_at: string;
    last_updated: string;
    created_by: string;
    version: string;
    team: string;
  };
}

interface ObservationTemplate {
  type: string;     // 'problem' | 'solution' | 'learning' | 'applicability' | 'link'
  content: string;
  date: string;
  metadata?: Record<string, any>;
}
```

Working LLM synthesis pattern (from createEntityObservation, line 802):
```typescript
const prompt = `Synthesize a concise, actionable observation from this entity data:
Entity: ${entity.name}
Type: ${entity.type || entity.entityType || 'Unknown'}
Raw Observations:
${rawContent}

Provide a JSON response with:
{
  "synthesizedContent": string,
  "keyPattern": string | null,
  "actionableGuidance": string,
  "relatedConcepts": string[],
  "confidence": number
}`;

const result = await this.semanticAnalyzer.analyzeContent(prompt, {
  analysisType: "general",
  provider: "auto",
  taskType: "observation_generation"
});
synthesizedObservation = JSON.parse(result.insights);
```

`this.semanticAnalyzer` is available on the class instance.
`log()` is available as a module-level function: `log(message: string, level: string, data?: any)`
`this.team` is available on the class instance for metadata.

From coordinator.ts (line 2634-2637):
```typescript
const semanticResult = await semanticAgent.analyzeGitAndVibeData(
  gitAnalysis,
  vibeAnalysis,
  { analysisDepth: 'surface' }
);
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix toPascalCase and generateCleanEntityName to preserve existing capitalization</name>
  <files>integrations/mcp-server-semantic-analysis/src/agents/observation-generation-agent.ts</files>
  <action>
**Fix 1: `toPascalCase()` at line 1684**

Replace the method body. Current buggy code:
```typescript
return words
  .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
  .join('');
```

Fixed code:
```typescript
private toPascalCase(input: string): string {
  const words = input
    .replace(/[-_]/g, ' ')
    .replace(/([a-z])([A-Z])/g, '$1 $2')
    .trim()
    .split(/\s+/)
    .filter(w => w.length > 0);

  return words
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))  // Remove .toLowerCase() -- preserve existing case
    .join('');
}
```

The ONLY change to the map function is removing `.toLowerCase()` from `word.slice(1)`. The camelCase split regex is already present. This preserves sub-word capitalization: "PathAnalyzer" splits to ["Path", "Analyzer"] which maps to ["Path", "Analyzer"] instead of ["Path", "Analyzer"] -> ["Path", "analyzer"].

**Fix 2: `generateCleanEntityName()` at line 1164**

Current buggy line:
```typescript
.map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase());
```

Replace with:
```typescript
.map(word => word.charAt(0).toUpperCase() + word.slice(1));
```

Also add camelCase boundary split to the word extraction chain, right after the `.replace(/[^a-zA-Z0-9\s]/g, ' ')` line:
```typescript
const words = description
  .replace(/[^a-zA-Z0-9\s]/g, ' ')
  .replace(/([a-z])([A-Z])/g, '$1 $2')  // Split camelCase boundaries
  .trim()
  .split(/\s+/)
  .filter(word => word.length > 2 && !fillerWords.has(word.toLowerCase()))
  .slice(0, 4)
  .map(word => word.charAt(0).toUpperCase() + word.slice(1));
```

**Fix 3: Improve `generateEntityName()` at line 1657**

The current method prepends type to description words, producing names like `ProblemSolutionImplementingPathAnalysis`. Per CONTEXT.md user decision (NAME-02): "use actual code identifiers when they exist, LLM-generated names for abstract patterns."

Update the method to check if the description already looks like a meaningful name (contains PascalCase words or is already a code identifier), and if so, use it directly with minimal formatting:

```typescript
private generateEntityName(type: string, description: string): string {
  // If description already looks like a PascalCase identifier, use it directly
  const alreadyPascalCase = /^[A-Z][a-zA-Z]+(?:[A-Z][a-zA-Z]+)+$/.test(description.trim());
  if (alreadyPascalCase) {
    return description.trim();
  }

  // Normalize type to PascalCase
  const typeFormatted = this.toPascalCase(type);

  // Normalize description: take first 4 meaningful words, PascalCase them
  const cleaned = this.toPascalCase(
    description
      .replace(/[^a-zA-Z0-9\s]/g, '')
      .trim()
      .split(/\s+/)
      .slice(0, 4)
      .join(' ')
  );

  return `${typeFormatted}${cleaned}`;
}
```

This preserves existing behavior for non-identifier descriptions while allowing code identifiers to pass through directly.
  </action>
  <verify>
    <automated>grep -n "\.toLowerCase()" integrations/mcp-server-semantic-analysis/src/agents/observation-generation-agent.ts | grep -c "slice(1)" | xargs test 0 -eq && echo "PASS: No toLowerCase on slice(1)"</automated>
  </verify>
  <done>
    - toPascalCase no longer destroys existing PascalCase sub-words
    - generateCleanEntityName splits on camelCase boundaries and preserves case
    - generateEntityName passes through already-PascalCase identifiers directly
    - "PathAnalyzer" produces "PathAnalyzer", not "Pathanalyzer"
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace template observations with LLM synthesis in createArchitecturalDecisionObservation and createCodeEvolutionObservation</name>
  <files>integrations/mcp-server-semantic-analysis/src/agents/observation-generation-agent.ts</files>
  <action>
**Fix 1: `createArchitecturalDecisionObservation()` (lines 289-361)**

Replace the template-string observation creation with LLM synthesis following the working pattern from `createEntityObservation()` (line 802).

Replace the observation-building section (lines 302-323) with:

```typescript
// LLM synthesis: Generate meaningful observations from architectural decision context
let synthesizedContent: any = null;
try {
  const relatedCommits = (gitAnalysis.commits || [])
    .filter((c: any) => c.files?.some((f: any) => (decision.files || []).includes(f.path)))
    .slice(0, 5)
    .map((c: any) => `- ${c.message}`)
    .join('\n') || '(no specific commits identified)';

  const prompt = `Analyze this architectural decision and produce a structured observation.

Decision Type: ${decision.type}
Description: ${decision.description}
Impact Level: ${decision.impact}
Key Files: ${decision.files.slice(0, 5).join(', ')}
Related Commits:
${relatedCommits}

Respond with JSON:
{
  "entityName": string,       // PascalCase name for this pattern/decision (e.g., "EventDrivenArchitecturePattern")
  "whatItIs": string,         // 1-2 sentences: what this architectural decision IS
  "whyItMatters": string,     // 1-2 sentences: WHY this matters for the codebase
  "guidance": string,         // 1-2 sentences: actionable guidance for developers
  "category": string          // "architecture" | "design-pattern" | "infrastructure" | "convention"
}`;

  const result = await this.semanticAnalyzer.analyzeContent(prompt, {
    analysisType: 'patterns',
    provider: 'auto',
    taskType: 'observation_generation'
  });

  const cleaned = result.insights
    .replace(/^```json?\n?/m, '').replace(/\n?```$/m, '').trim();
  synthesizedContent = JSON.parse(cleaned);

  log('LLM-synthesized architectural decision observation', 'debug', {
    entityName: synthesizedContent.entityName,
    category: synthesizedContent.category
  });
} catch (error) {
  log('LLM synthesis failed for architectural decision, using basic content', 'warning', {
    type: decision.type,
    error: error instanceof Error ? error.message : String(error)
  });
}
```

Then build the observations array using synthesized content with template fallback:

```typescript
const observations: (string | ObservationTemplate)[] = [];

if (synthesizedContent) {
  observations.push({
    type: 'problem',
    content: synthesizedContent.whatItIs,
    date: currentDate
  });
  observations.push({
    type: 'solution',
    content: synthesizedContent.whyItMatters,
    date: currentDate
  });
  observations.push({
    type: 'learning',
    content: synthesizedContent.guidance,
    date: currentDate
  });
} else {
  // Fallback: basic content from decision data (not useless template)
  observations.push({
    type: 'problem',
    content: `${decision.type}: ${decision.description}`,
    date: currentDate
  });
  observations.push({
    type: 'solution',
    content: `Impact: ${decision.impact}. Files: ${decision.files.slice(0, 3).join(', ')}`,
    date: currentDate
  });
}
```

If `synthesizedContent?.entityName` exists and looks like a valid PascalCase name, use it as `entityName` instead of `this.generateEntityName(decision.type, decision.description)`. This fulfills NAME-02 (LLM-generated names for abstract patterns).

**Fix 2: `createCodeEvolutionObservation()` (lines 363-403+)**

Apply the same LLM synthesis pattern. Replace the template observations (lines 375-403) with:

```typescript
let synthesizedContent: any = null;
try {
  const prompt = `Analyze this code evolution pattern and produce a structured observation.

Pattern: ${pattern.pattern}
Frequency: ${pattern.occurrences} occurrences
Trend: ${pattern.trend}
Key Files: ${pattern.files.slice(0, 5).join(', ')}

Respond with JSON:
{
  "entityName": string,       // PascalCase name for this evolution pattern
  "whatItIs": string,         // 1-2 sentences: what this code evolution pattern IS
  "whyItMatters": string,     // 1-2 sentences: WHY understanding this pattern matters
  "guidance": string,         // 1-2 sentences: actionable guidance for developers
  "trendInsight": string      // 1 sentence: what the trend direction means
}`;

  const result = await this.semanticAnalyzer.analyzeContent(prompt, {
    analysisType: 'patterns',
    provider: 'auto',
    taskType: 'observation_generation'
  });

  const cleaned = result.insights
    .replace(/^```json?\n?/m, '').replace(/\n?```$/m, '').trim();
  synthesizedContent = JSON.parse(cleaned);

  log('LLM-synthesized code evolution observation', 'debug', {
    entityName: synthesizedContent.entityName
  });
} catch (error) {
  log('LLM synthesis failed for code evolution, using basic content', 'warning', {
    pattern: pattern.pattern,
    error: error instanceof Error ? error.message : String(error)
  });
}
```

Build observations array with synthesized content and fallback, same structure as the architectural decision fix above.

If `synthesizedContent?.entityName` exists, use it instead of `this.generateEntityName('CodeEvolution', pattern.pattern)`.

**Error visibility (per CONTEXT.md decision):** After the main `generateObservations()` method completes (at the end of the method before the return), add a summary log:

```typescript
log('Observation generation complete', 'info', {
  totalObservations: observations.length,
  byType: {
    architecturalDecisions: (gitAnalysis.architecturalDecisions || []).length,
    codeEvolution: (gitAnalysis.codeEvolutionPatterns || []).length,
    entities: (semanticAnalysis?.entities || []).length
  }
});
```
  </action>
  <verify>
    <automated>cd /Users/Q284340/Agentic/coding && grep -c "semanticAnalyzer.analyzeContent" integrations/mcp-server-semantic-analysis/src/agents/observation-generation-agent.ts | xargs test 3 -le && echo "PASS: LLM synthesis calls present"</automated>
  </verify>
  <done>
    - createArchitecturalDecisionObservation uses LLM synthesis, not template strings
    - createCodeEvolutionObservation uses LLM synthesis, not template strings
    - Both methods have graceful fallback on LLM failure (basic content from input data, not useless templates)
    - LLM-generated entity names are used when available (NAME-02)
    - Code fence stripping applied before JSON.parse
    - End-of-generation summary logged with counts
  </done>
</task>

<task type="auto">
  <name>Task 3: Switch analysisDepth from surface to deep in coordinator</name>
  <files>integrations/mcp-server-semantic-analysis/src/agents/coordinator.ts</files>
  <action>
Single-line fix at line 2637 of `coordinator.ts`.

Change:
```typescript
{ analysisDepth: 'surface' }
```

To:
```typescript
{ analysisDepth: 'deep' }
```

Also update the comment on line 2628 from "surface depth for batch efficiency" to "deep depth for meaningful code understanding".

This is the only change needed in coordinator.ts. The `semantic-analysis-agent.ts` already handles 'deep' mode correctly (line 295: `options.analysisDepth || 'deep'`).
  </action>
  <verify>
    <automated>cd /Users/Q284340/Agentic/coding && grep "analysisDepth" integrations/mcp-server-semantic-analysis/src/agents/coordinator.ts | grep -q "deep" && echo "PASS: analysisDepth is deep"</automated>
  </verify>
  <done>
    - coordinator.ts passes analysisDepth 'deep' to semantic analysis agent
    - Comment updated to reflect the intent
    - No other changes in coordinator.ts
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify end-to-end:

1. **TypeScript compilation**: `cd integrations/mcp-server-semantic-analysis && npx tsc --noEmit` -- must pass with no errors
2. **No template strings in observation methods**: `grep -n "When working with\|DO: Follow the\|DON'T: Deviate" src/agents/observation-generation-agent.ts` should return zero matches in createArchitecturalDecisionObservation and createCodeEvolutionObservation
3. **LLM synthesis present**: `grep -c "semanticAnalyzer.analyzeContent" src/agents/observation-generation-agent.ts` should be >= 3 (existing createEntityObservation + two new)
4. **PascalCase fix**: `grep "toLowerCase()" src/agents/observation-generation-agent.ts` should NOT appear on any line containing `slice(1)` in toPascalCase or generateCleanEntityName
5. **Deep analysis**: `grep "analysisDepth" src/agents/coordinator.ts` should show 'deep'
</verification>

<success_criteria>
- toPascalCase and generateCleanEntityName preserve existing PascalCase sub-words
- generateEntityName passes through already-PascalCase identifiers directly
- createArchitecturalDecisionObservation uses LLM synthesis with graceful fallback
- createCodeEvolutionObservation uses LLM synthesis with graceful fallback
- LLM-generated entity names used when available
- coordinator passes analysisDepth 'deep'
- TypeScript compiles without errors
- Observation generation summary logged at end
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-pipeline-data-quality/01-02-SUMMARY.md`
</output>
